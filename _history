{"entries":[{"timestamp":1720100563661,"editorVersion":"7.0.13","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"d\"\n    ]"],[1,",\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":225,"start2":225,"length1":11,"length2":42}]}]},{"timestamp":1720100702807,"editorVersion":"7.0.13","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables>"],[1,"www.w3.org/1999/xhtml\">\n  "],[0,"<blo"]],"start1":12,"start2":12,"length1":70,"length2":37},{"diffs":[[0,"art\""],[-1," x=\"20\" y=\"20\""],[0,"></b"]],"start1":67,"start2":67,"length1":22,"length2":8},{"diffs":[[0,"</block>"],[1,"\n  "],[0,"<block t"]],"start1":72,"start2":72,"length1":16,"length2":19},{"diffs":[[0,"ver\""],[-1," x=\"225\" y=\"20\""],[0,"></b"]],"start1":107,"start2":107,"length1":23,"length2":8},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"// tests go here; this will not be compiled when this package is used as an extension.\nenum Task {\n    Scan,\n    SetNorth,\n    Measure\n}\nfunction performSetup() {\n    let result = 0\n    switch (nextTask) {\n        case Task.Scan:\n            let scanTime = 6000 // ...to MANUALLY rotate turntable jig twice (SMOOOOTHLY!)\n            basic.showString(\"S\")\n            basic.pause(1000)\n            basic.showString(\"_\")\n            heading.scanClockwise(scanTime)\n            basic.showIcon(IconNames.Yes)\n            basic.pause(1000)\n            basic.clearScreen()\n            basic.showArrow(ArrowNames.West)\n            nextTask = Task.SetNorth\n            break\n\n        case Task.SetNorth:\n            basic.showString(\"N\")\n            basic.pause(1000)\n            basic.clearScreen()\n            result = heading.setNorth()\n\n            if (result < 0) {\n                basic.showIcon(IconNames.Skull) // problem with scan data analysis\n                basic.pause(1000)\n                basic.showNumber(result)\n                basic.pause(1000)\n                basic.clearScreen()\n                basic.showArrow(ArrowNames.West)\n                nextTask = Task.Scan // restart with a fresh scan\n            } else {\n                spinRPM = heading.spinRate() // ...just out of interest\n                basic.showNumber(Math.floor(spinRPM))\n                basic.pause(1000)\n                basic.showIcon(IconNames.Yes)\n                basic.pause(500)\n                basic.showLeds(`\n                    # # . # #\n                    # . . . #\n                    . . # . .\n                    # . . . #\n                    # # . # #\n                    `)\n                basic.pause(500)\n                basic.showArrow(ArrowNames.East)\n                nextTask = Task.Measure\n            }\n            break\n\n        case Task.Measure: // Button A allows new North setting\n            basic.showIcon(IconNames.No)\n            basic.pause(1000)\n            basic.clearScreen()\n            basic.showArrow(ArrowNames.West)\n            nextTask = Task.SetNorth // reset new North\n            break\n    }\n\n}\n\nfunction measure() {\n    switch (nextTask) {\n        // ? sequence error?\n        case Task.SetNorth:\n        case Task.Scan: // use button A to do a scan first\n            for (let i = 0; i < 5; i++) {\n                basic.clearScreen()\n                basic.pause(100)\n                basic.showArrow(ArrowNames.West)\n            }\n            break\n\n        case Task.Measure: // OK, take a new heading measurement\n            basic.pause(200)\n            basic.clearScreen()\n            basic.pause(50)\n            let compass = heading.degrees()\n            basic.showNumber(Math.floor(compass))\n            basic.pause(500)\n            // now MANUALLY move to next test-angle...\n            basic.showLeds(`\n                    # # . # #\n                    # . . . #\n                    . . . . .\n                    # . . . #\n                    # # . # #\n                    `)\n            basic.pause(200)\n            break\n    }\n\n}\n\ninput.onButtonPressed(Button.A, function () {\n    performSetup()\n})\n\ninput.onButtonPressed(Button.B, function () {\n    measure()\n})\n\nlet nextTask: Task = Task.Scan // new mode, so always start with a scan\nlet spinRPM = 0\nbasic.showArrow(ArrowNames.West)"],[0,"\n"]],"start1":0,"start2":0,"length1":3322,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".md\""],[-1,",\n        \"pxt-heading.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\""],[1,"\n    ]"],[0,"\n}\n"]],"start1":223,"start2":223,"length1":71,"length2":13}]},{"type":"added","filename":"pxt-heading.ts","value":"\n// TODO? No use is yet made of the accelerometer. Although seemingly helpful to compensate for\n// static tilt, on a moving buggy dynamic sideways accelerations confound the measurement of \"down\",\n// so applying tilt-compensation could actually make compass-heading accuracy worse!\n\n\n\n//% color=#6080e0 weight=40 icon=\"\\uf14e\" block=\"Heading\" \n/**\n * An extension providing a compass-bearing for a buggy located anywhere on the globe \n * (except at the magnetic poles!), with any arbitrary mounting orientation for its microbit.\n * \n * See the README for a detailed description of the approach, methods and algorithms.\n */\nnamespace heading {\n\n    // ENUMERATIONS\n    enum View { // the axis-pairs that span the three possible magnetometer projection planes\n        XY,\n        YZ,\n        ZX\n    }\n\n    // CONSTANTS\n\n    const HalfPi = Math.PI / 2\n    const TwoPi = 2 * Math.PI\n    const ThreePi = 3 * Math.PI\n    const RadianDegrees = 360 / TwoPi\n    const EnoughScanTime = 1500 // minimum acceptable scan-time\n    const EnoughSamples = 70 // fewest acceptable scan samples\n    const TooManySamples = 500 // don't be too greedy with memory!\n    const MarginalField = 10 // minimum acceptable field-strength for magnetometer readings\n    const Circular = 1.03 // maximum eccentricity to consider an Ellipse as \"circular\" (3% gives ~1 degree error)\n    const NearEnough = 0.75 // major-axis candidates must be longer than (longest*NearEnough)\n    // minor-axis candidates must be shorter than (shortest/NearEnough) \n    const Window = 8 // number of magnetometer samples needed to form a good average\n    const SampleGap = 15 // minimum ms to wait between magnetometer readings\n    const AverageGap = 25 // (achieved in practice, due to system interrupts)\n    const Latency = Window * AverageGap // consequent time taken to collect a good moving average from scratch\n\n    // SUPPORTING CLASSES\n\n    // An Arrow is an object holding a directed vector {u,v} in both Cartesian and Polar coordinates. \n    // It also carries a time-field, used to timestamp scanned samples.\n    // An Arrow is used to hold a 2D magnetometer measurement as a re-centred vector.\n\n    class Arrow {\n        u: number; // horizontal component\n        v: number; // vertical component\n        size: number; // polar magnitude of vector\n        angle: number; // polar angle (radians anticlockwise from East)\n        time: number; // for scan samples, timestamp of when this was collected\n\n        constructor(u: number, v: number, t: number) {\n            this.u = u\n            this.v = v\n            this.size = Math.sqrt((u * u) + (v * v))\n            this.angle = 0\n            if (this.size > 0) { // defend against zero-divide\n                this.angle = Math.atan2(v, u)\n            }\n            this.time = t\n        }\n        // when copying...\n        cloneMe(): Arrow {\n            return new Arrow(this.u, this.v, this.time)\n        }\n    }\n\n    // A Smoother object computes a moving average from a sequence of time-stamped values: \n    // in our case, magnetometer readings and their derivatives.\n    // Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n    // The constant {Window} governs the latency of the exponential averaging process.\n    // Smoothers can work with arbitrary-sized vectors of values that share the same timestamp.\n    // history[], previous[], latest[] and result[] arrays will be either 3-D, (for initial [X,Y,Z] scanning)\n    // or 2-D, (for analysing chosen the [uDim,vDim]).\n    class Smoother {\n        dims: number; // dimensionality\n        average: number[] = []; // \n        lastTime: number;\n        lastInputs: number[] = [];\n\n        constructor(first: number[], start: number) {\n            this.dims = first.length\n            this.lastTime = start\n            for (let i = 0; i < this.dims; i++) {\n                this.average.push(first[i])\n                this.lastInputs.push(first[i])\n            }\n        }\n\n        update(values: number[], timeStamp: number): number[] {\n            // work out appropriate blend, based on time-step\n            let timeFraction = (timeStamp - this.lastTime) / Latency\n            let keepOld = Math.exp(-timeFraction)\n            let inherited = (1 - keepOld) / timeFraction\n            // we amplify the most recent sample's contribution to the inherited average\n            let boostLast = (inherited - keepOld)\n            let addNew = (1 - inherited)\n            // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n            // apply blending to all elements of old and new data arrays\n            let result: number[] = []\n            for (let i = 0; i < this.dims; i++) {\n                result.push(keepOld * this.average[i]\n                    + boostLast * this.lastInputs[i]\n                    + addNew * values[i])\n            }\n            // update history for next time around\n            this.lastTime = timeStamp\n            this.average = result\n            this.lastInputs = values\n\n            return result\n        }\n    }\n\n\n    // An Ellipse is an object holding the characteristics of the (typically) elliptical\n    // view formed when projecting the scan Spin-Circle onto a 2-axis View-plane.\n    class Ellipse {\n        plane: string; // View name (just for debug)\n        uDim: number; // horizontal axis of this View\n        vDim: number; // vertical axis of this View\n        uOff: number; // horizontal offset needed to re-centre this Ellipse along the U-axis\n        vOff: number; // vertical offset needed to re-centre this Ellipse along the V-axis\n\n        // calibration characteristics\n        majorAngle: number; // direction of the Ellipse major axis \n        period: number; // scan-rotation time as viewed in this plane\n        eccentricity: number; // ratio of major-axis to minor-axis magnitudes for this Ellipse\n        isCircular: boolean; // flag saying this \"Ellipse\" View is almost circular, simplifying future handling\n        rotationSense: number; // rotation reversal sign = +/-1, reflecting this Ellipse's view of the clockwise scan\n\n        constructor(plane: string, uDim: number, vDim: number, uOff: number, vOff: number) {\n            this.plane = plane // (as a DEBUG aid)\n            this.uDim = uDim\n            this.vDim = vDim\n            this.uOff = uOff\n            this.vOff = vOff\n            this.isCircular = false // until proved otherwise!\n            this.period = -1\n        }\n\n        // This method analyses a 2-D subset of the scanData for a projected View of the Spin-Circle,\n        // creating an Arrow indicating the major-axis direction of the elliptical View.\n        // It performs several tasks:\n        // 1) By comparing the longest and shortest radii, this method works out the eccentricity of \n        //    the Ellipse, as seen from this View. Also notes whether being viewed \"from below\".\n        // 2) It collects possible candidates for the Ellipse major and minor axes by looking for local \n        //    radius peaks and troughs; candidate values are pushed onto two lists of Arrows:\n        //    this.majors[] and this.minors[]\n        // 3) These lists are then carefully assessed to evolve a consensus for the two axes. \n        //    For \"pointy\" Ellipses we get a single candidate each time we pass either end of the axis.\n        //    For \"rounder\" Ellipses each transit may deliver multiple candidates. If a candidate points \n        //    closer to the head of the ongoing mean, it is added in; if it points closer to the tail, \n        //    then it's inverse is added in (as it must \"belong\" to the other end of the axis).\n        // 4) As we do this, we work out the rotation period by clocking each time we flip ends of the axis.\n        // 5) All this analysis results in a single Arrow for each axis which can be averaged (after turning\n        //    the minor axis through a right-angle)\n\n\n        analyseView() {\n            let majors: Arrow[] = [] // candidate directions for major axis of Ellipse\n            let minors: Arrow[] = [] // candidate directions for minor axis of Ellipse\n            let major: Arrow = new Arrow(0, 0, 0)\n            let minor: Arrow = new Arrow(0, 0, 0)\n            let longest = 0\n            let shortest = 99999\n            let spin = 0\n            let sizeWas: number\n            let angleWas: number\n            let step: number = 99999 // marker for \"first time round\"\n            let stepWas: number\n            // extract coordinates of the first point lying in this.plane\n            let point = [scanData[0][this.uDim], scanData[0][this.vDim]]\n            // set up a 2D Smoother for points on this Ellipse\n            let curve = new Smoother(point, scanTimes[0])\n            // compare first one with remaining samples\n            let trial = new Arrow(point[0], point[1], scanTimes[0])\n            for (let i = 1; i < scanTimes.length; i++) {\n                sizeWas = trial.size\n                angleWas = trial.angle\n                // blend the next point into the moving average\n                point = curve.update([scanData[i][this.uDim], scanData[i][this.vDim]], scanTimes[i])\n                trial = new Arrow(point[0], point[1], scanTimes[i])\n\n                // accumulate gradual rotation of the projected field-vector...\n                let delta = trial.angle - angleWas\n                spin += delta\n                // fix roll-rounds in either direction\n                if (delta > HalfPi) spin -= TwoPi // apparent big positive jump is due to underflow\n                if (delta < -HalfPi) spin += TwoPi // apparent big negative jump is due to overflow\n\n                // now collect candidates for axes  \n                stepWas = step\n                step = trial.size - sizeWas // is radius growing or shrinking (or the same!)?\n                if (stepWas == 99999) stepWas = step // (ensure that the first two steps will always match)\n                if (step == 0) step = stepWas // ignore any (rare!) static sequence by propagating last step\n\n                // look for peaks, where we switch from growing to shrinking\n                if ((stepWas > 0) && (step < 0)) {\n                    longest = Math.max(longest, trial.size)\n                    majors.push(trial.cloneMe()) // copy the major axis we are passing\n                }\n\n                // look for troughs, where we switch from shrinking to growing\n                if ((stepWas < 0) && (step > 0)) {\n                    shortest = Math.min(shortest, trial.size)\n                    minors.push(trial.cloneMe()) // copy the minor axis we are passing\n                }\n\n            }\n            // During a clockwise scan, the projection-angle of the field-vector as viewed from above \n            // will appear to rotate anticlockwise (increasing radians) from the perspective of the Buggy. \n            // If we find it rotates clockwise (decreasing radians) then this projection-plane must be \n            // viewing the field-vector from below.\n            this.rotationSense = spin / Math.abs(spin) // == -1 if viewing from below\n\n            /* PERIODICITY FROM SPIN?\n             Why not simply use the accumulated spin-angle and time-span to calculate the rotation-period?\n             --Because the arbitrary start and end angles may be subject to fore-shortening, and hence\n             quite inaccurate! The only dependable angles occur just as we pass over the axes (see below).\n            */\n\n\n            /* We are trying to find a good approximation to the tilt of the Ellipse's major-axis.  \n            We could simply nominate the longest candidate detected, but instead we will average them.\n\n            If the Ellipse is quite eccentric, it will yield neatly alternating candidates with \n            \"opposite\" angles.passing the major-axis twice per Spin-circle revolution \n\n            With a more-nearly circular Ellipse, noisy readings can yield alternating clusters of local maxima \n            gathered near each end of the axis.\n\n            An almost circular Ellipse has no meaningful axis and generally yields multiple spurious candidates. \n            */\n\n            // purge any local maximum whose vector length is too short --it's nowhere near the major-axis!\n            let long = longest * NearEnough\n            for (let i = 0; i < majors.length; i++) {\n                if (majors[i].size < long) {\n                    majors.splice(i, 1)  // disqualified!\n                    i-- // (all subsequent candidates now shuffle up by one place!)\n                }\n            }\n\n            // similarly purge all errant local minima that are too big\n            let short = shortest / NearEnough\n            for (let i = 0; i < minors.length; i++) {\n                if (minors[i].size > short) {\n                    minors.splice(i, 1)\n                    i--\n                }\n            }\n\n\n            // form consensus averages of the two ends of the two axes\n            major = computeAxis(majors)\n            minor = computeAxis(minors)\n\n            // average the axis angles carefully: minor axis is always orthgonal, but phase may lead or follow!\n            let minorTurned = minor.angle + HalfPi // assume it leads by 90 degrees\n            if (angleSpan(major.angle, minor.angle) > 0) {\n                minorTurned += Math.PI // no: it follows, so add another 180 degrees\n            }\n            // use the average of the two angles\n            this.majorAngle = ((major.angle + minorTurned) / 2) % TwoPi\n            // The ratio of the axis lengths gives the eccentricity of this Ellipse\n            this.eccentricity = major.size / minor.size\n            // average the periodicities detected \n            this.period = (major.time + minor.time) / 2\n            // Readings on a near-circular Ellipse won't ever be fore-shortened, so we can skip correction!\n            this.isCircular = (this.eccentricity < Circular)\n        }\n    }\n\n\n\n    // GLOBALS\n\n    let scanTimes: number[] = [] // sequence of time-stamps for scanned readings \n    let scanData: number[][] = [] // scanned sequence of [X,Y,Z] magnetometer readings\n    let scanTime: number = 0 // duration of scan in ms\n    let views: Ellipse[] = [] // the three possible elliptical views of the Spin-Circle\n    let bestView = -1\n    let uDim = -1 // the \"horizontal\" axis (called U) for the best View\n    let vDim = -1 // the \"vertical\" axis (called V) for the best View\n    let north = 0 // reading registered as \"North\"\n    let strength = 0 // the average magnetic field-strength observed by the magnetometer\n    let period = -1 // overall assessment of average rotation time\n\n    // correction parameters adopted from bestView Ellipse for future readings\n    let rotationSense = 1 // set to -1 if orientation means field-vector projection is \"from below\"\n    let isCircular: boolean // if bestView Ellipse is circular, no correction is needed\n    let uOff: number // horizontal origin offset\n    let vOff: number // vertical origin offset\n    let theta: number  // major-axis tilt angle (in radians anticlockwise from the U-axis)\n    let cosTheta: number; // saved for efficiency\n    let sinTheta: number; //      ditto\n    let scale: number // stretch-factor for correcting foreshortened readings (= eccentricity)\n\n    // EXPORTED USER INTERFACES   \n\n    /** \n     * Assuming the buggy is currently spinning clockwise on the spot, capture a \n     * time-stamped sequence of magnetometer readings from which to set up the compass.\n     *\n     * @param ms scanning-time in millisecs (long enough for more than one full rotation)    \n     */\n\n    //% block=\"scan clockwise for (ms) $ms\" \n    //% inlineInputMode=inline \n    //% ms.shadow=\"timePicker\" \n    //% ms.defl=0 \n    //% weight=90 \n\n    export function scanClockwise(ms: number) {\n        // Sample magnetometer readings periodically over the specified duration (generally a couple\n        // of seconds), and append a new [X,Y,Z] triple to the scanData[] array.\n        // A timestamp for each sample is also recorded in the scanTimes[] array.\n\n        // NOTE: To smooth out jitter, each reading is always a moving average of several consecutive readings.\n        // Because sample-times may be irregular (due to scheduled interrupts), a Smoother is used to provide\n        // a timing-aware exponential moving-average. The sample-grouping and spacing are controlled \n        // respectively by the constants Window and SampleGap, which together determine the Latency.\n\n        scanTimes = []\n        scanData = []\n        let index = 0\n\n        let timeWas: number\n        let timeNow: number\n        let fresh: number[] = []\n        let updated: number[] = []\n\n        basic.pause(200) // wait for motors to stabilise (after initial kick)\n        // get initial reading\n        let timeStamp = input.runningTime()\n        fresh = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n        // use a Smoother to maintain a rolling average\n        let scan = new Smoother(fresh, timeStamp)\n\n        // after an initial settling period, continue cranking out updated moving averages \n        let startTime = timeStamp + Latency\n        let stopTime = timeStamp + ms\n\n        // until we run out of time (or space!)\n        while ((timeStamp < stopTime)\n            && (scanTimes.length < TooManySamples)) {\n            // After processing, sleep until it's time for next sample.\n            // NOTE: here is where various system subprograms will get scheduled.\n            // If they need more time than we've offered, out next sample will get delayed!\n            // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n            timeWas = timeStamp // remember time of latest sample\n            timeNow = input.runningTime()\n            basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n            timeStamp = input.runningTime() // take a fresh set of readings\n\n            fresh = [\n                input.magneticForce(Dimension.X),\n                input.magneticForce(Dimension.Y),\n                input.magneticForce(Dimension.Z)]\n            updated = scan.update(fresh, timeStamp)\n\n            // only start recording once the moving average has stabilised\n            if (timeStamp > startTime) {\n                // store the triple of averaged [X,Y,Z] values (as a deep copy!)\n                scanData.push([updated[0], updated[1], updated[2]])\n                scanTimes.push(timeStamp)  // timestamp it\n                index++\n            }\n        }\n    }\n\n    /**\n     * Analyse the scanned data to prepare for reading compass-bearings.\n     * Then read the magnetometer and register the buggy's current direction as \"North\",\n     * (i.e. the direction that will in future return zero as its heading).\n     * \n     * The actual direction of the buggy when this function is called is arbitrary:\n     * it could be Magnetic North; or True North (compensating for local declination); \n     * or any convenient direction from which to measure subsequent heading angles.\n     * \n     * @return zero if successful, or a negative error code:\n     *\n     *      -1 : NOT ENOUGH SCAN DATA\n\n     *      -2 : FIELD STRENGTH TOO WEAK\n     *\n     *      -3 : NOT ENOUGH SCAN ROTATION\n     *\n     */\n    //% block=\"set North\" \n    //% inlineInputMode=inline \n    //% weight=80 \n    export function setNorth(): number {\n        // reset global defaults\n        bestView = -1\n        strength = -1\n        period = -1\n\n        // First analyse the scan-data to decide how best to use the magnetometer readings.\n        // we'll typically need about a couple of second's worth of scanned readings...\n        let nSamples = scanTimes.length\n        scanTime = scanTimes[nSamples - 1] - scanTimes[0]\n\n        if ((nSamples < EnoughSamples) || (scanTime < EnoughScanTime)) {\n            return -1 // \"NOT ENOUGH SCAN DATA\"\n        }\n        // Each dimension should track a sinusoidal wave of values (generally not centred on zero).\n        // The first pass finds the ranges for each axis \n        let xlo = 9999999\n        let ylo = 9999999\n        let zlo = 9999999\n        let xhi = -9999999\n        let yhi = -9999999\n        let zhi = -9999999\n        for (let i = 0; i < nSamples; i++) {\n            xhi = Math.max(xhi, scanData[i][Dimension.X])\n            yhi = Math.max(yhi, scanData[i][Dimension.Y])\n            zhi = Math.max(zhi, scanData[i][Dimension.Z])\n            xlo = Math.min(xlo, scanData[i][Dimension.X])\n            ylo = Math.min(ylo, scanData[i][Dimension.Y])\n            zlo = Math.min(zlo, scanData[i][Dimension.Z])\n        }\n\n        // get RMS field-strength\n        let xField = (xhi - xlo) / 2\n        let yField = (yhi - ylo) / 2\n        let zField = (zhi - zlo) / 2\n        strength = Math.sqrt((xField * xField) + (yField * yField) + (zField * zField))\n\n        // Bail out early if the scan didn't properly detect the Earth's magnetic field,\n        // (perhaps due to magnetic shielding)\n        if (strength < MarginalField) {\n            return -2 // \"FIELD STRENGTH TOO WEAK\"\n        }\n        // The means of the extremes give an approximation to the central offsets.\n        let xOff = (xhi + xlo) / 2\n        let yOff = (yhi + ylo) / 2\n        let zOff = (zhi + zlo) / 2\n\n        // re-centre all of the scanData samples, so eliminating \"hard-iron\" magnetic effects\n        for (let i = 0; i < nSamples; i++) {\n            scanData[i][Dimension.X] -= xOff\n            scanData[i][Dimension.Y] -= yOff\n            scanData[i][Dimension.Z] -= zOff\n        }\n\n        // create three Ellipse instances for analysing each possible view in turn\n        views.push(new Ellipse(\"XY\", Dimension.X, Dimension.Y, xOff, yOff))\n        views.push(new Ellipse(\"YZ\", Dimension.Y, Dimension.Z, yOff, zOff))\n        views.push(new Ellipse(\"ZX\", Dimension.Z, Dimension.X, zOff, xOff))\n\n        // For each View, perform the analysis of eccentricity and Ellipse tilt-angle\n        views[View.XY].analyseView()\n        views[View.YZ].analyseView()\n        views[View.ZX].analyseView()\n\n        // check that at least one View saw at least one complete rotation (with a measurable period)...\n        if ((views[View.XY].period == -1)\n            && (views[View.YZ].period == -1)\n            && (views[View.ZX].period == -1)) {\n            return -3 // \"NOT ENOUGH SCAN ROTATION\"\n        }\n\n        // Choose the \"roundest\" Ellipse  --the one with lowest eccentricity.\n        bestView = View.XY\n        if (views[View.YZ].eccentricity < views[bestView].eccentricity) bestView = View.YZ\n        if (views[View.ZX].eccentricity < views[bestView].eccentricity) bestView = View.ZX\n\n        // periodicity is unreliable in a near-circular View: average just the other two Views' measurements\n        period = (views[0].period + views[1].period + views[2].period - views[bestView].period) / 2\n\n        // For efficiency, extract various characteristics from our adopted \"bestView\" Ellipse\n        uDim = views[bestView].uDim\n        vDim = views[bestView].vDim\n        uOff = views[bestView].uOff\n        vOff = views[bestView].vOff\n        scale = views[bestView].eccentricity // scaling needed to balance axes\n        theta = views[bestView].majorAngle // the rotation (in radians) of the major-axis from the U-axis\n        cosTheta = Math.cos(theta)\n        sinTheta = Math.sin(theta)\n        isCircular = views[bestView].isCircular\n        rotationSense = views[bestView].rotationSense\n\n        // Having successfully set up the projection parameters for the bestView, get a\n        // stable fix on the current heading, which we will then designate as \"North\".\n        // (This is the global fixed bias to be subtracted from all future readings)\n        north = takeSingleReading()\n\n        // we've now finished with the scanning data and Ellipse objects, so release their memory\n        scanTimes = []\n        scanData = []\n        views = []\n\n        // SUCCESS!\n        return 0\n    }\n\n\n    /**\n     * Read the magnetometer\n     * \n     * @return the current heading of the buggy\n     * \n     * (in degrees clockwise, relative to \"North\")\n     */\n    //% block=\"degrees\" \n    //% inlineInputMode=inline \n    //% weight=70\n    export function degrees(): number {\n        // Depending on mounting orientation, the bestView might possibly be seeing the Spin-Circle from\n        // \"underneath\", with the field-vector appearing to move clockwise  --effectively experiencing an\n        // anti-clockwise scan. In this case the rotationSense will be negative.\n        return asDegrees((takeSingleReading() - north) * rotationSense)\n        // NOTE: that there is a double reversal going on here:\n        // Viewed from above, the Field-vector reading in radians INCREASES (anticlockwise) w.r.t \"North\"\n        // as the buggy's compass-heading INCREASES (clockwise).\n        // So after a right-turn while facing North, the reading is HalfPi bigger than the North reading.\n        // After subtracting North (cyclically), that converts asDegrees() to +90 \n        // From below (when rotationSense = -1), the same right-turn would DECREASE the reading by HalfPi\n        // necessitating a third reversal (after first subtracting North) !\n    }\n\n    /**\n     * The average rotation time of the most recent scan \n     * @return rotation time, or error-value:\n     * \n     *      -4 : SUCCESSFUL SCAN IS NEEDED FIRST\n     */\n    //% block=\"spin time (ms)\" \n    //% inlineInputMode=inline \n    //% weight=60 \n    export function spinTime(): number {\n        if (period == -1) {\n            return -4 // ERROR: SUCCESSFUL SCAN IS NEEDED FIRST\n        } else {\n            return period\n        }\n    }\n\n    /**\n     * The average rotation rate of the most recent scan \n     * \n     * @return revs-per-minute, or error value:\n     * \n     *      -4 : SUCCESSFUL SCAN IS NEEDED FIRST\n     */\n    //% block=\"spin rate (RPM)\" \n    //% inlineInputMode=inline \n    //% weight=50 \n    export function spinRate(): number {\n        if (period == -1) {\n            return -4 // ERROR: SUCCESSFUL SCAN IS NEEDED FIRST\n        } else {\n            return 60000 / period\n        }\n    }\n\n    /**\n     * While scanning, wheels are rotated in opposite directions, giving a spin-rate for the \n     * selected power setting. Based on the axle-length and latest spin-rate, this function \n     * estimates the forward speed to be expected when using that power setting.\n     * (NOTE that tyre-friction or skidding when turning may make this a fairly inaccurate estimate!)\n     * \n     * @param axleLength : distance betweeen mid-lines of tyres (in mm)\n     * \n     * @return speed in mm-per-second, or error value:\n     * \n     *      -4 : SUCCESSFUL SCAN IS NEEDED FIRST\n     */\n    //% block=\"equivalent speed (mm/s), axle length (mm) = $axleLength\" \n    //% inlineInputMode=inline \n    //% weight=50 \n    export function equivalentSpeed(axleLength: number): number {\n        if (period < 0) {\n            return -4 // ERROR: SUCCESSFUL SCAN IS NEEDED FIRST\n        } else {\n            // compute tangential speed of wheel-centre in mm/s:\n            // it takes [period] ms to cover [2pi * axleLength/2] mm\n            return (Math.PI * axleLength * 1000 / period)\n        }\n    }\n\n\n    // UTILITY FUNCTIONS\n\n    /** Take the sum of several new readings to get a stable fix on the current heading.\n     *  @return the projected angle of the magnetic field-vector (in radians anticlockwise\n     * from the horizontal U-axis)\n     */\n\n    function takeSingleReading(): number {\n        let uRaw = 0\n        let vRaw = 0\n        let u = 0\n        let v = 0\n        let uNew = 0\n        let vNew = 0\n        let uFix = 0\n        let vFix = 0\n        let reading = 0\n        // get a new sample as the average of {Window} consecutive 2D readings, {SampleGap} apart\n        for (let i = 0; i < Window; i++) {\n            basic.pause(SampleGap)\n            uRaw += input.magneticForce(uDim)\n            vRaw += input.magneticForce(vDim)\n        }\n        uRaw /= Window\n        vRaw /= Window\n\n        // re-centre this latest point w.r.t our Ellipse origin\n        u = uRaw - uOff\n        v = vRaw - vOff\n\n        if (isCircular) {\n            reading = Math.atan2(v, u)\n        } else {\n            // Unless this Ellipse.isCircular, any {u,v} reading will be foreshortened in this View, and\n            // must be stretched along the Ellipse minor-axis to place it correctly onto the Spin-Circle.\n\n            // First rotate CLOCKWISE by theta (so aligning the Ellipse minor-axis angle with the V-axis)\n            uNew = u * cosTheta + v * sinTheta\n            vNew = v * cosTheta - u * sinTheta\n            // Now scale up along V, re-balancing the axes to make the Ellipse circular\n            uFix = uNew\n            vFix = vNew * scale\n            // get the adjusted angle for this corrected {u,v}\n            reading = Math.atan2(vFix, uFix)\n            // finally, undo the rotation by theta\n            reading += theta\n        }\n        return reading\n    }\n\n    /* Use vector addition to average a sequence of candidate axis Arrows (concievably empty!)\n    // The ones pointing away from the first one are assumed to belong to the other end\n    // of the axis, so will get reversed.\n    // The returned Arrow shows the average axis length and angle.\n    // Assuming candidates represent more than one revolution, the periodocity is also calculated.\n    */\n    function computeAxis(sheaf: Arrow[]): Arrow {\n        let result = new Arrow(0, 0, 0)\n        let turns = 0\n        let startTime = 0\n        let endTime = 0\n        let period = -1\n        let flipped = false\n        let uSum = 0\n        let vSum = 0\n        let rSum = 0\n        let count = sheaf.length\n        if (count > 0) {\n            // initialise axis as first (or only?) candidate\n            uSum = sheaf[0].u\n            vSum = sheaf[0].v\n            rSum = sheaf[0].size\n            let axis = sheaf[0].angle\n            startTime = sheaf[0].time\n            flipped = false\n            for (let i = 1; i < count; i++) {\n                // does next candidate point nearer the head or the tail of the axis?\n                if (Math.abs(angleSpan(axis, sheaf[i].angle)) < HalfPi) {\n                    // chain this candidate onto the emerging axis\n                    uSum += sheaf[i].u\n                    vSum += sheaf[i].v\n                    // the first unflipped candidate after one or more flipped ones clocks a new revolution\n                    if (flipped) {\n                        flipped = false\n                        turns++\n                        endTime = sheaf[i].time\n                    }\n                } else { // flip this arrow before chaining it, as it's pointing the \"wrong\" way\n                    flipped = true\n                    uSum -= sheaf[i].u\n                    vSum -= sheaf[i].v\n                }\n                // get the new blended angle\n                axis = Math.atan2(vSum, uSum)\n                rSum += sheaf[i].size\n            }\n\n            // build the result Arrow\n            result.size = rSum / count  // the average radius\n            result.angle = axis\n            result.u = result.size * Math.cos(axis)\n            result.v = result.size * Math.sin(axis)\n\n            // compute the average rotation time (so long as we've made at least one complete revolution)\n            if (endTime > 0) {\n                result.time = (endTime - startTime) / turns\n            }\n        }\n        // hijack the time property to return the estimated period\n        return result\n    }\n\n\n    /** gives the signed difference between angles a & b (allowing for roll-round)\n     * @param a first angle in radians\n     * @param b second angle in radians\n     * @returns the acute (i.e. smaller) difference in angle\n     */\n    function angleSpan(a: number, b: number) {\n        return ((ThreePi + b - a) % TwoPi) - Math.PI\n    }\n\n    // Convert an angle measured in radians to degrees.\n    function asDegrees(angle: number): number {\n        return ((angle * RadianDegrees) + 360) % 360\n    }\n}\n"}]},{"timestamp":1721227065354,"editorVersion":"7.0.13","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"pe=\""],[-1,"function_definition\" x=\"10\" y=\"10\"><mutation name=\"performSetup\" functionid=\"[vA;:54=Q=ye][K9n$dl\"></mutation><field name=\"function_name\">performSetup</field><statement name=\"STACK\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"switch (nextTask) {\" line1=\"        case Task.Scan:\" line2=\"            let scanTime = 6000 // ...to MANUALLY rotate turntable jig twice (SMOOOOTHLY!)\" line3=\"            basic.showString(&quot;S&quot;)\" line4=\"            basic.pause(1000)\" line5=\"            basic.showString(&quot;_&quot;)\" line6=\"            heading.scanClockwise(scanTime)\" line7=\"            basic.showIcon(IconNames.Yes)\" line8=\"            basic.pause(1000)\" line9=\"            basic.clearScreen()\" line10=\"            basic.showArrow(ArrowNames.West)\" line11=\"            nextTask = Task.SetNorth\" line12=\"            break\" line13=\"\" line14=\"        case Task.SetNorth:\" line15=\"            basic.showString(&quot;N&quot;)\" line16=\"            basic.pause(1000)\" line17=\"            basic.clearScreen()\" line18=\"            result = heading.setNorth()\" line19=\"\" line20=\"            if (result &lt; 0) {\" line21=\"                basic.showIcon(IconNames.Skull) // problem with scan data analysis\" line22=\"                basic.pause(1000)\" line23=\"                basic.showNumber(result)\" line24=\"                basic.pause(1000)\" line25=\"                basic.clearScreen()\" line26=\"                basic.showArrow(ArrowNames.West)\" line27=\"                nextTask = Task.Scan // restart with a fresh scan\" line28=\"            } else {\" line29=\"                spinRPM = heading.spinRate() // ...just out of interest\" line30=\"                basic.showNumber(Math.floor(spinRPM))\" line31=\"                basic.pause(1000)\" line32=\"                basic.showIcon(IconNames.Yes)\" line33=\"                basic.pause(500)\" line34=\"                basic.showLeds(`\" line35=\"                    # # . # #\" line36=\"                    # . . . #\" line37=\"                    . . # . .\" line38=\"                    # . . . #\" line39=\"                    # # . # #\" line40=\"                    `)\" line41=\"                basic.pause(500)\" line42=\"                basic.showArrow(ArrowNames.East)\" line43=\"                nextTask = Task.Measure\" line44=\"            }\" line45=\"            break\" line46=\"\" line47=\"        case Task.Measure: // Button A allows new North setting\" line48=\"            basic.showIcon(IconNames.No)\" line49=\"            basic.pause(1000)\" line50=\"            basic.clearScreen()\" line51=\"            basic.showArrow(ArrowNames.West)\" line52=\"            nextTask = Task.SetNorth // reset new North\" line53=\"            break\" line54=\"    }\" numlines=\"55\"></mutation></block></statement></block><block type=\"function_definition\" x=\"10\" y=\"10\"><mutation name=\"measure\" functionid=\"(?z$N_d[_95s,b)]Uce3\"></mutation><field name=\"function_name\">measure</field><statement name=\"STACK\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"switch (nextTask) {\" line1=\"        // ? sequence error?\" line2=\"        case Task.SetNorth:\" line3=\"        case Task.Scan: // use button A to do a scan first\" line4=\"            for (let i = 0; i &lt; 5; i++) {\" line5=\"                basic.clearScreen()\" line6=\"                basic.pause(100)\" line7=\"                basic.showArrow(ArrowNames.West)\" line8=\"            }\" line9=\"            break\" line10=\"\" line11=\"        case Task.Measure: // OK, take a new heading measurement\" line12=\"            basic.pause(200)\" line13=\"            basic.clearScreen()\" line14=\"            basic.pause(50)\" line15=\"            let compass = heading.degrees()\" line16=\"            basic.showNumber(Math.floor(compass))\" line17=\"            basic.pause(500)\" line18=\"            // now MANUALLY move to next test-angle...\" line19=\"            basic.showLeds(`\" line20=\"                    # # . # #\" line21=\"                    # . . . #\" line22=\"                    . . . . .\" line23=\"                    # . . . #\" line24=\"                    # # . # #\" line25=\"                    `)\" line26=\"            basic.pause(200)\" line27=\"            break\" line28=\"    }\" numlines=\"29\"></mutation></block></statement></block><block type=\"device_button_event\" x=\"10\" y=\"10\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"performSetup\" functionid=\"[vA;:54=Q=ye][K9n$dl\"></mutation></block></statement></block><block type=\"device_button_event\" x=\"10\" y=\"10\"><field name=\"NAME\">Button.B</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"measure\" functionid=\"(?z$N_d[_95s,b)]Uce3\"></mutation></block></statement></block><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let spinRPM = 0\" numlines=\"1\" declaredvars=\"spinRPM\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let result = 0\" numlines=\"1\" declaredvars=\"result\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"enum Task {\" line1=\"    Scan,\" line2=\"    SetNorth,\" line3=\"    Measure\" line4=\"}\" numlines=\"5\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let nextTask: Task = Task.Scan\" numlines=\"1\" declaredvars=\"nextTask\"></mutation><comment pinned=\"false\" h=\"50\" w=\"50\">new mode, so always start with a scan</comment><next><block type=\"basic_show_arrow\"><value name=\"i\"><shadow type=\"device_arrow\"><field name=\"arrow\">ArrowNames.West</field></shadow></value></block></next></block></next></block></next></block></next></block></statement"],[1,"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\""],[0,"></b"]],"start1":87,"start2":87,"length1":5902,"length2":87}]}]},{"timestamp":1721227066104,"editorVersion":"7.0.13","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"pe=\""],[-1,"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let spinRPM = 0\" numlines=\"1\" declaredvars=\"spinRPM\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let result = 0\" numlines=\"1\" declaredvars=\"result\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"enum Task {\" line1=\"    Scan,\" line2=\"    SetNorth,\" line3=\"    Measure\" line4=\"}\" numlines=\"5\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let nextTask: Task = Task.Scan\" numlines=\"1\" declaredvars=\"nextTask\"></mutation><comment pinned=\"false\" h=\"50\" w=\"50\">new mode, so always start with a scan</comment><next><block type=\"basic_show_arrow\"><value name=\"i\"><shadow type=\"device_arrow\"><field name=\"arrow\">ArrowNames.West</field></shadow></value></block></next></block></next></block></next></block></next></block></statement></block><block type=\"device_button_event\" x=\"386\" y=\"20\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"performSetup\" functionid=\"[vA;:54=Q=ye][K9n$dl\"></mutation></block></statement></block><block type=\"device_button_event\" x=\"648\" y=\"20\"><field name=\"NAME\">Button.B</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"measure\" functionid=\"(?z$N_d[_95s,b)]Uce3\"></mutation></block></statement></block><block type=\"function_definition\" x=\"911\" y=\"2"],[1,"function_definition\" x=\"10\" y=\"1"],[0,"0\"><"]],"start1":87,"start2":87,"length1":1654,"length2":40},{"diffs":[[0,"x=\"1"],[-1,"78"],[0,"0\" y=\""],[-1,"2"],[1,"1"],[0,"0\"><"]],"start1":2910,"start2":2910,"length1":17,"length2":15},{"diffs":[[0,"/block><"],[1,"block type=\"device_button_event\" x=\"10\" y=\"10\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"performSetup\" functionid=\"[vA;:54=Q=ye][K9n$dl\"></mutation></block></statement></block><block type=\"device_button_event\" x=\"10\" y=\"10\"><field name=\"NAME\">Button.B</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"measure\" functionid=\"(?z$N_d[_95s,b)]Uce3\"></mutation></block></statement></block><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let spinRPM = 0\" numlines=\"1\" declaredvars=\"spinRPM\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let result = 0\" numlines=\"1\" declaredvars=\"result\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"enum Task {\" line1=\"    Scan,\" line2=\"    SetNorth,\" line3=\"    Measure\" line4=\"}\" numlines=\"5\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let nextTask: Task = Task.Scan\" numlines=\"1\" declaredvars=\"nextTask\"></mutation><comment pinned=\"false\" h=\"50\" w=\"50\">new mode, so always start with a scan</comment><next><block type=\"basic_show_arrow\"><value name=\"i\"><shadow type=\"device_arrow\"><field name=\"arrow\">ArrowNames.West</field></shadow></value></block></next></block></next></block></next></block></next></block></statement></block><"],[0,"/xml>"]],"start1":4376,"start2":4376,"length1":13,"length2":1624}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[1,"// tests go here; this will not be compiled when this package is used as an extension.\nenum Task {\n    Scan,\n    SetNorth,\n    Measure\n}\n"],[0,"function perform"]],"start1":0,"start2":0,"length1":16,"length2":153},{"diffs":[[0,"ormSetup"],[-1," "],[0,"() {\n"],[1,"    let result = 0\n"],[0,"    swit"]],"start1":150,"start2":150,"length1":22,"length2":40},{"diffs":[[0,"  }\n"],[1,"\n"],[0,"}\n"],[-1,"input.onButtonPressed(Button.A, function () {\n    performSetup()\n})\ninput.onButtonPressed(Button.B, function () {\n    measure()\n})"],[0,"\nfun"]],"start1":2115,"start2":2115,"length1":140,"length2":11},{"diffs":[[0," measure"],[-1," "],[0,"() {\n   "]],"start1":2131,"start2":2131,"length1":17,"length2":16},{"diffs":[[0,"  }\n"],[1,"\n"],[0,"}\n"],[-1,"let spinRPM = 0\nlet result = 0\nenum Task {\n    Scan,\n    SetNorth,"],[1,"\ninput.onButtonPressed(Button.A, function () {\n    performSetup()\n})\n\ninput.onButtonPressed(Button.B, function () {"],[0,"\n    "],[-1,"M"],[1,"m"],[0,"easure"],[-1,"\n}\n"],[1,"()\n})\n\nlet nextTask: Task = Task.Scan "],[0,"// n"]],"start1":3060,"start2":3060,"length1":91,"length2":176},{"diffs":[[0,"let "],[-1,"nextTask: Task = Task.Scan"],[1,"spinRPM = 0"],[0,"\nbas"]],"start1":3273,"start2":3273,"length1":34,"length2":19}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":277,"start2":277,"length1":21,"length2":17}]}]},{"timestamp":1721283117806,"editorVersion":"7.0.13","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"art\" x=\""],[1,"2"],[0,"0\" y=\""],[1,"2"],[0,"0\"><stat"]],"start1":100,"start2":100,"length1":22,"length2":24},{"diffs":[[0,"x=\"3"],[-1,"6"],[1,"8"],[0,"6\" y=\""],[1,"2"],[0,"0\"><"]],"start1":1248,"start2":1248,"length1":15,"length2":16},{"diffs":[[0,"x=\"6"],[-1,"2"],[1,"4"],[0,"8\" y=\""],[1,"2"],[0,"0\"><"]],"start1":1489,"start2":1489,"length1":15,"length2":16},{"diffs":[[0," x=\""],[-1,"8"],[0,"9"],[1,"1"],[0,"1\" y=\""],[1,"2"],[0,"0\"><"]],"start1":1724,"start2":1724,"length1":16,"length2":17},{"diffs":[[0,"=\"17"],[-1,"6"],[1,"8"],[0,"0\" y=\""],[1,"2"],[0,"0\"><"]],"start1":4525,"start2":4525,"length1":15,"length2":16}]}]},{"timestamp":1721283121906,"editorVersion":"7.0.13","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":277,"start2":277,"length1":17,"length2":21}]}]},{"timestamp":1721491854776,"editorVersion":"7.0.13","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"ADME.md\""],[1,",\n        \"pxt-heading.ts\""],[0,"\n    ],\n"]],"start1":219,"start2":219,"length1":16,"length2":42}]},{"type":"removed","filename":"pxt-heading.ts","value":"\n// TODO? No use is yet made of the accelerometer. Although seemingly helpful to compensate for\n// static tilt, on a moving buggy dynamic sideways accelerations confound the measurement of \"down\",\n// so applying tilt-compensation could actually make compass-heading accuracy worse!\n\n\n\n//% color=#6080e0 weight=40 icon=\"\\uf14e\" block=\"Heading\" \n/**\n * An extension providing a compass-bearing for a buggy located anywhere on the globe \n * (except at the magnetic poles!), with any arbitrary mounting orientation for its microbit.\n * \n * See the README for a detailed description of the approach, methods and algorithms.\n */\nnamespace heading {\n\n    // ENUMERATIONS\n    enum View { // the axis-pairs that span the three possible magnetometer projection planes\n        XY,\n        YZ,\n        ZX\n    }\n\n    // CONSTANTS\n\n    const HalfPi = Math.PI / 2\n    const TwoPi = 2 * Math.PI\n    const ThreePi = 3 * Math.PI\n    const RadianDegrees = 360 / TwoPi\n    const EnoughScanTime = 1500 // minimum acceptable scan-time\n    const EnoughSamples = 70 // fewest acceptable scan samples\n    const TooManySamples = 500 // don't be too greedy with memory!\n    const MarginalField = 10 // minimum acceptable field-strength for magnetometer readings\n    const Circular = 1.03 // maximum eccentricity to consider an Ellipse as \"circular\" (3% gives ~1 degree error)\n    const NearEnough = 0.75 // major-axis candidates must be longer than (longest*NearEnough)\n    // minor-axis candidates must be shorter than (shortest/NearEnough) \n    const Window = 8 // number of magnetometer samples needed to form a good average\n    const SampleGap = 15 // minimum ms to wait between magnetometer readings\n    const AverageGap = 25 // (achieved in practice, due to system interrupts)\n    const Latency = Window * AverageGap // consequent time taken to collect a good moving average from scratch\n\n    // SUPPORTING CLASSES\n\n    // An Arrow is an object holding a directed vector {u,v} in both Cartesian and Polar coordinates. \n    // It also carries a time-field, used to timestamp scanned samples.\n    // An Arrow is used to hold a 2D magnetometer measurement as a re-centred vector.\n\n    class Arrow {\n        u: number; // horizontal component\n        v: number; // vertical component\n        size: number; // polar magnitude of vector\n        angle: number; // polar angle (radians anticlockwise from East)\n        time: number; // for scan samples, timestamp of when this was collected\n\n        constructor(u: number, v: number, t: number) {\n            this.u = u\n            this.v = v\n            this.size = Math.sqrt((u * u) + (v * v))\n            this.angle = 0\n            if (this.size > 0) { // defend against zero-divide\n                this.angle = Math.atan2(v, u)\n            }\n            this.time = t\n        }\n        // when copying...\n        cloneMe(): Arrow {\n            return new Arrow(this.u, this.v, this.time)\n        }\n    }\n\n    // A Smoother object computes a moving average from a sequence of time-stamped values: \n    // in our case, magnetometer readings and their derivatives.\n    // Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n    // The constant {Window} governs the latency of the exponential averaging process.\n    // Smoothers can work with arbitrary-sized vectors of values that share the same timestamp.\n    // history[], previous[], latest[] and result[] arrays will be either 3-D, (for initial [X,Y,Z] scanning)\n    // or 2-D, (for analysing chosen the [uDim,vDim]).\n    class Smoother {\n        dims: number; // dimensionality\n        average: number[] = []; // \n        lastTime: number;\n        lastInputs: number[] = [];\n\n        constructor(first: number[], start: number) {\n            this.dims = first.length\n            this.lastTime = start\n            for (let i = 0; i < this.dims; i++) {\n                this.average.push(first[i])\n                this.lastInputs.push(first[i])\n            }\n        }\n\n        update(values: number[], timeStamp: number): number[] {\n            // work out appropriate blend, based on time-step\n            let timeFraction = (timeStamp - this.lastTime) / Latency\n            let keepOld = Math.exp(-timeFraction)\n            let inherited = (1 - keepOld) / timeFraction\n            // we amplify the most recent sample's contribution to the inherited average\n            let boostLast = (inherited - keepOld)\n            let addNew = (1 - inherited)\n            // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n            // apply blending to all elements of old and new data arrays\n            let result: number[] = []\n            for (let i = 0; i < this.dims; i++) {\n                result.push(keepOld * this.average[i]\n                    + boostLast * this.lastInputs[i]\n                    + addNew * values[i])\n            }\n            // update history for next time around\n            this.lastTime = timeStamp\n            this.average = result\n            this.lastInputs = values\n\n            return result\n        }\n    }\n\n\n    // An Ellipse is an object holding the characteristics of the (typically) elliptical\n    // view formed when projecting the scan Spin-Circle onto a 2-axis View-plane.\n    class Ellipse {\n        plane: string; // View name (just for debug)\n        uDim: number; // horizontal axis of this View\n        vDim: number; // vertical axis of this View\n        uOff: number; // horizontal offset needed to re-centre this Ellipse along the U-axis\n        vOff: number; // vertical offset needed to re-centre this Ellipse along the V-axis\n\n        // calibration characteristics\n        majorAngle: number; // direction of the Ellipse major axis \n        period: number; // scan-rotation time as viewed in this plane\n        eccentricity: number; // ratio of major-axis to minor-axis magnitudes for this Ellipse\n        isCircular: boolean; // flag saying this \"Ellipse\" View is almost circular, simplifying future handling\n        rotationSense: number; // rotation reversal sign = +/-1, reflecting this Ellipse's view of the clockwise scan\n\n        constructor(plane: string, uDim: number, vDim: number, uOff: number, vOff: number) {\n            this.plane = plane // (as a DEBUG aid)\n            this.uDim = uDim\n            this.vDim = vDim\n            this.uOff = uOff\n            this.vOff = vOff\n            this.isCircular = false // until proved otherwise!\n            this.period = -1\n        }\n\n        // This method analyses a 2-D subset of the scanData for a projected View of the Spin-Circle,\n        // creating an Arrow indicating the major-axis direction of the elliptical View.\n        // It performs several tasks:\n        // 1) By comparing the longest and shortest radii, this method works out the eccentricity of \n        //    the Ellipse, as seen from this View. Also notes whether being viewed \"from below\".\n        // 2) It collects possible candidates for the Ellipse major and minor axes by looking for local \n        //    radius peaks and troughs; candidate values are pushed onto two lists of Arrows:\n        //    this.majors[] and this.minors[]\n        // 3) These lists are then carefully assessed to evolve a consensus for the two axes. \n        //    For \"pointy\" Ellipses we get a single candidate each time we pass either end of the axis.\n        //    For \"rounder\" Ellipses each transit may deliver multiple candidates. If a candidate points \n        //    closer to the head of the ongoing mean, it is added in; if it points closer to the tail, \n        //    then it's inverse is added in (as it must \"belong\" to the other end of the axis).\n        // 4) As we do this, we work out the rotation period by clocking each time we flip ends of the axis.\n        // 5) All this analysis results in a single Arrow for each axis which can be averaged (after turning\n        //    the minor axis through a right-angle)\n\n\n        analyseView() {\n            let majors: Arrow[] = [] // candidate directions for major axis of Ellipse\n            let minors: Arrow[] = [] // candidate directions for minor axis of Ellipse\n            let major: Arrow = new Arrow(0, 0, 0)\n            let minor: Arrow = new Arrow(0, 0, 0)\n            let longest = 0\n            let shortest = 99999\n            let spin = 0\n            let sizeWas: number\n            let angleWas: number\n            let step: number = 99999 // marker for \"first time round\"\n            let stepWas: number\n            // extract coordinates of the first point lying in this.plane\n            let point = [scanData[0][this.uDim], scanData[0][this.vDim]]\n            // set up a 2D Smoother for points on this Ellipse\n            let curve = new Smoother(point, scanTimes[0])\n            // compare first one with remaining samples\n            let trial = new Arrow(point[0], point[1], scanTimes[0])\n            for (let i = 1; i < scanTimes.length; i++) {\n                sizeWas = trial.size\n                angleWas = trial.angle\n                // blend the next point into the moving average\n                point = curve.update([scanData[i][this.uDim], scanData[i][this.vDim]], scanTimes[i])\n                trial = new Arrow(point[0], point[1], scanTimes[i])\n\n                // accumulate gradual rotation of the projected field-vector...\n                let delta = trial.angle - angleWas\n                spin += delta\n                // fix roll-rounds in either direction\n                if (delta > HalfPi) spin -= TwoPi // apparent big positive jump is due to underflow\n                if (delta < -HalfPi) spin += TwoPi // apparent big negative jump is due to overflow\n\n                // now collect candidates for axes  \n                stepWas = step\n                step = trial.size - sizeWas // is radius growing or shrinking (or the same!)?\n                if (stepWas == 99999) stepWas = step // (ensure that the first two steps will always match)\n                if (step == 0) step = stepWas // ignore any (rare!) static sequence by propagating last step\n\n                // look for peaks, where we switch from growing to shrinking\n                if ((stepWas > 0) && (step < 0)) {\n                    longest = Math.max(longest, trial.size)\n                    majors.push(trial.cloneMe()) // copy the major axis we are passing\n                }\n\n                // look for troughs, where we switch from shrinking to growing\n                if ((stepWas < 0) && (step > 0)) {\n                    shortest = Math.min(shortest, trial.size)\n                    minors.push(trial.cloneMe()) // copy the minor axis we are passing\n                }\n\n            }\n            // During a clockwise scan, the projection-angle of the field-vector as viewed from above \n            // will appear to rotate anticlockwise (increasing radians) from the perspective of the Buggy. \n            // If we find it rotates clockwise (decreasing radians) then this projection-plane must be \n            // viewing the field-vector from below.\n            this.rotationSense = spin / Math.abs(spin) // == -1 if viewing from below\n\n            /* PERIODICITY FROM SPIN?\n             Why not simply use the accumulated spin-angle and time-span to calculate the rotation-period?\n             --Because the arbitrary start and end angles may be subject to fore-shortening, and hence\n             quite inaccurate! The only dependable angles occur just as we pass over the axes (see below).\n            */\n\n\n            /* We are trying to find a good approximation to the tilt of the Ellipse's major-axis.  \n            We could simply nominate the longest candidate detected, but instead we will average them.\n\n            If the Ellipse is quite eccentric, it will yield neatly alternating candidates with \n            \"opposite\" angles.passing the major-axis twice per Spin-circle revolution \n\n            With a more-nearly circular Ellipse, noisy readings can yield alternating clusters of local maxima \n            gathered near each end of the axis.\n\n            An almost circular Ellipse has no meaningful axis and generally yields multiple spurious candidates. \n            */\n\n            // purge any local maximum whose vector length is too short --it's nowhere near the major-axis!\n            let long = longest * NearEnough\n            for (let i = 0; i < majors.length; i++) {\n                if (majors[i].size < long) {\n                    majors.splice(i, 1)  // disqualified!\n                    i-- // (all subsequent candidates now shuffle up by one place!)\n                }\n            }\n\n            // similarly purge all errant local minima that are too big\n            let short = shortest / NearEnough\n            for (let i = 0; i < minors.length; i++) {\n                if (minors[i].size > short) {\n                    minors.splice(i, 1)\n                    i--\n                }\n            }\n\n\n            // form consensus averages of the two ends of the two axes\n            major = computeAxis(majors)\n            minor = computeAxis(minors)\n\n            // average the axis angles carefully: minor axis is always orthgonal, but phase may lead or follow!\n            let minorTurned = minor.angle + HalfPi // assume it leads by 90 degrees\n            if (angleSpan(major.angle, minor.angle) > 0) {\n                minorTurned += Math.PI // no: it follows, so add another 180 degrees\n            }\n            // use the average of the two angles\n            this.majorAngle = ((major.angle + minorTurned) / 2) % TwoPi\n            // The ratio of the axis lengths gives the eccentricity of this Ellipse\n            this.eccentricity = major.size / minor.size\n            // average the periodicities detected \n            this.period = (major.time + minor.time) / 2\n            // Readings on a near-circular Ellipse won't ever be fore-shortened, so we can skip correction!\n            this.isCircular = (this.eccentricity < Circular)\n        }\n    }\n\n\n\n    // GLOBALS\n\n    let scanTimes: number[] = [] // sequence of time-stamps for scanned readings \n    let scanData: number[][] = [] // scanned sequence of [X,Y,Z] magnetometer readings\n    let scanTime: number = 0 // duration of scan in ms\n    let views: Ellipse[] = [] // the three possible elliptical views of the Spin-Circle\n    let bestView = -1\n    let uDim = -1 // the \"horizontal\" axis (called U) for the best View\n    let vDim = -1 // the \"vertical\" axis (called V) for the best View\n    let north = 0 // reading registered as \"North\"\n    let strength = 0 // the average magnetic field-strength observed by the magnetometer\n    let period = -1 // overall assessment of average rotation time\n\n    // correction parameters adopted from bestView Ellipse for future readings\n    let rotationSense = 1 // set to -1 if orientation means field-vector projection is \"from below\"\n    let isCircular: boolean // if bestView Ellipse is circular, no correction is needed\n    let uOff: number // horizontal origin offset\n    let vOff: number // vertical origin offset\n    let theta: number  // major-axis tilt angle (in radians anticlockwise from the U-axis)\n    let cosTheta: number; // saved for efficiency\n    let sinTheta: number; //      ditto\n    let scale: number // stretch-factor for correcting foreshortened readings (= eccentricity)\n\n    // EXPORTED USER INTERFACES   \n\n    /** \n     * Assuming the buggy is currently spinning clockwise on the spot, capture a \n     * time-stamped sequence of magnetometer readings from which to set up the compass.\n     *\n     * @param ms scanning-time in millisecs (long enough for more than one full rotation)    \n     */\n\n    //% block=\"scan clockwise for (ms) $ms\" \n    //% inlineInputMode=inline \n    //% ms.shadow=\"timePicker\" \n    //% ms.defl=0 \n    //% weight=90 \n\n    export function scanClockwise(ms: number) {\n        // Sample magnetometer readings periodically over the specified duration (generally a couple\n        // of seconds), and append a new [X,Y,Z] triple to the scanData[] array.\n        // A timestamp for each sample is also recorded in the scanTimes[] array.\n\n        // NOTE: To smooth out jitter, each reading is always a moving average of several consecutive readings.\n        // Because sample-times may be irregular (due to scheduled interrupts), a Smoother is used to provide\n        // a timing-aware exponential moving-average. The sample-grouping and spacing are controlled \n        // respectively by the constants Window and SampleGap, which together determine the Latency.\n\n        scanTimes = []\n        scanData = []\n        let index = 0\n\n        let timeWas: number\n        let timeNow: number\n        let fresh: number[] = []\n        let updated: number[] = []\n\n        basic.pause(200) // wait for motors to stabilise (after initial kick)\n        // get initial reading\n        let timeStamp = input.runningTime()\n        fresh = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n        // use a Smoother to maintain a rolling average\n        let scan = new Smoother(fresh, timeStamp)\n\n        // after an initial settling period, continue cranking out updated moving averages \n        let startTime = timeStamp + Latency\n        let stopTime = timeStamp + ms\n\n        // until we run out of time (or space!)\n        while ((timeStamp < stopTime)\n            && (scanTimes.length < TooManySamples)) {\n            // After processing, sleep until it's time for next sample.\n            // NOTE: here is where various system subprograms will get scheduled.\n            // If they need more time than we've offered, out next sample will get delayed!\n            // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n            timeWas = timeStamp // remember time of latest sample\n            timeNow = input.runningTime()\n            basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n            timeStamp = input.runningTime() // take a fresh set of readings\n\n            fresh = [\n                input.magneticForce(Dimension.X),\n                input.magneticForce(Dimension.Y),\n                input.magneticForce(Dimension.Z)]\n            updated = scan.update(fresh, timeStamp)\n\n            // only start recording once the moving average has stabilised\n            if (timeStamp > startTime) {\n                // store the triple of averaged [X,Y,Z] values (as a deep copy!)\n                scanData.push([updated[0], updated[1], updated[2]])\n                scanTimes.push(timeStamp)  // timestamp it\n                index++\n            }\n        }\n    }\n\n    /**\n     * Analyse the scanned data to prepare for reading compass-bearings.\n     * Then read the magnetometer and register the buggy's current direction as \"North\",\n     * (i.e. the direction that will in future return zero as its heading).\n     * \n     * The actual direction of the buggy when this function is called is arbitrary:\n     * it could be Magnetic North; or True North (compensating for local declination); \n     * or any convenient direction from which to measure subsequent heading angles.\n     * \n     * @return zero if successful, or a negative error code:\n     *\n     *      -1 : NOT ENOUGH SCAN DATA\n\n     *      -2 : FIELD STRENGTH TOO WEAK\n     *\n     *      -3 : NOT ENOUGH SCAN ROTATION\n     *\n     */\n    //% block=\"set North\" \n    //% inlineInputMode=inline \n    //% weight=80 \n    export function setNorth(): number {\n        // reset global defaults\n        bestView = -1\n        strength = -1\n        period = -1\n\n        // First analyse the scan-data to decide how best to use the magnetometer readings.\n        // we'll typically need about a couple of second's worth of scanned readings...\n        let nSamples = scanTimes.length\n        scanTime = scanTimes[nSamples - 1] - scanTimes[0]\n\n        if ((nSamples < EnoughSamples) || (scanTime < EnoughScanTime)) {\n            return -1 // \"NOT ENOUGH SCAN DATA\"\n        }\n        // Each dimension should track a sinusoidal wave of values (generally not centred on zero).\n        // The first pass finds the ranges for each axis \n        let xlo = 9999999\n        let ylo = 9999999\n        let zlo = 9999999\n        let xhi = -9999999\n        let yhi = -9999999\n        let zhi = -9999999\n        for (let i = 0; i < nSamples; i++) {\n            xhi = Math.max(xhi, scanData[i][Dimension.X])\n            yhi = Math.max(yhi, scanData[i][Dimension.Y])\n            zhi = Math.max(zhi, scanData[i][Dimension.Z])\n            xlo = Math.min(xlo, scanData[i][Dimension.X])\n            ylo = Math.min(ylo, scanData[i][Dimension.Y])\n            zlo = Math.min(zlo, scanData[i][Dimension.Z])\n        }\n\n        // get RMS field-strength\n        let xField = (xhi - xlo) / 2\n        let yField = (yhi - ylo) / 2\n        let zField = (zhi - zlo) / 2\n        strength = Math.sqrt((xField * xField) + (yField * yField) + (zField * zField))\n\n        // Bail out early if the scan didn't properly detect the Earth's magnetic field,\n        // (perhaps due to magnetic shielding)\n        if (strength < MarginalField) {\n            return -2 // \"FIELD STRENGTH TOO WEAK\"\n        }\n        // The means of the extremes give an approximation to the central offsets.\n        let xOff = (xhi + xlo) / 2\n        let yOff = (yhi + ylo) / 2\n        let zOff = (zhi + zlo) / 2\n\n        // re-centre all of the scanData samples, so eliminating \"hard-iron\" magnetic effects\n        for (let i = 0; i < nSamples; i++) {\n            scanData[i][Dimension.X] -= xOff\n            scanData[i][Dimension.Y] -= yOff\n            scanData[i][Dimension.Z] -= zOff\n        }\n\n        // create three Ellipse instances for analysing each possible view in turn\n        views.push(new Ellipse(\"XY\", Dimension.X, Dimension.Y, xOff, yOff))\n        views.push(new Ellipse(\"YZ\", Dimension.Y, Dimension.Z, yOff, zOff))\n        views.push(new Ellipse(\"ZX\", Dimension.Z, Dimension.X, zOff, xOff))\n\n        // For each View, perform the analysis of eccentricity and Ellipse tilt-angle\n        views[View.XY].analyseView()\n        views[View.YZ].analyseView()\n        views[View.ZX].analyseView()\n\n        // check that at least one View saw at least one complete rotation (with a measurable period)...\n        if ((views[View.XY].period == -1)\n            && (views[View.YZ].period == -1)\n            && (views[View.ZX].period == -1)) {\n            return -3 // \"NOT ENOUGH SCAN ROTATION\"\n        }\n\n        // Choose the \"roundest\" Ellipse  --the one with lowest eccentricity.\n        bestView = View.XY\n        if (views[View.YZ].eccentricity < views[bestView].eccentricity) bestView = View.YZ\n        if (views[View.ZX].eccentricity < views[bestView].eccentricity) bestView = View.ZX\n\n        // periodicity is unreliable in a near-circular View: average just the other two Views' measurements\n        period = (views[0].period + views[1].period + views[2].period - views[bestView].period) / 2\n\n        // For efficiency, extract various characteristics from our adopted \"bestView\" Ellipse\n        uDim = views[bestView].uDim\n        vDim = views[bestView].vDim\n        uOff = views[bestView].uOff\n        vOff = views[bestView].vOff\n        scale = views[bestView].eccentricity // scaling needed to balance axes\n        theta = views[bestView].majorAngle // the rotation (in radians) of the major-axis from the U-axis\n        cosTheta = Math.cos(theta)\n        sinTheta = Math.sin(theta)\n        isCircular = views[bestView].isCircular\n        rotationSense = views[bestView].rotationSense\n\n        // Having successfully set up the projection parameters for the bestView, get a\n        // stable fix on the current heading, which we will then designate as \"North\".\n        // (This is the global fixed bias to be subtracted from all future readings)\n        north = takeSingleReading()\n\n        // we've now finished with the scanning data and Ellipse objects, so release their memory\n        scanTimes = []\n        scanData = []\n        views = []\n\n        // SUCCESS!\n        return 0\n    }\n\n\n    /**\n     * Read the magnetometer\n     * \n     * @return the current heading of the buggy\n     * \n     * (in degrees clockwise, relative to \"North\")\n     */\n    //% block=\"degrees\" \n    //% inlineInputMode=inline \n    //% weight=70\n    export function degrees(): number {\n        // Depending on mounting orientation, the bestView might possibly be seeing the Spin-Circle from\n        // \"underneath\", with the field-vector appearing to move clockwise  --effectively experiencing an\n        // anti-clockwise scan. In this case the rotationSense will be negative.\n        return asDegrees((takeSingleReading() - north) * rotationSense)\n        // NOTE: that there is a double reversal going on here:\n        // Viewed from above, the Field-vector reading in radians INCREASES (anticlockwise) w.r.t \"North\"\n        // as the buggy's compass-heading INCREASES (clockwise).\n        // So after a right-turn while facing North, the reading is HalfPi bigger than the North reading.\n        // After subtracting North (cyclically), that converts asDegrees() to +90 \n        // From below (when rotationSense = -1), the same right-turn would DECREASE the reading by HalfPi\n        // necessitating a third reversal (after first subtracting North) !\n    }\n\n    /**\n     * The average rotation time of the most recent scan \n     * @return rotation time, or error-value:\n     * \n     *      -4 : SUCCESSFUL SCAN IS NEEDED FIRST\n     */\n    //% block=\"spin time (ms)\" \n    //% inlineInputMode=inline \n    //% weight=60 \n    export function spinTime(): number {\n        if (period == -1) {\n            return -4 // ERROR: SUCCESSFUL SCAN IS NEEDED FIRST\n        } else {\n            return period\n        }\n    }\n\n    /**\n     * The average rotation rate of the most recent scan \n     * \n     * @return revs-per-minute, or error value:\n     * \n     *      -4 : SUCCESSFUL SCAN IS NEEDED FIRST\n     */\n    //% block=\"spin rate (RPM)\" \n    //% inlineInputMode=inline \n    //% weight=50 \n    export function spinRate(): number {\n        if (period == -1) {\n            return -4 // ERROR: SUCCESSFUL SCAN IS NEEDED FIRST\n        } else {\n            return 60000 / period\n        }\n    }\n\n    /**\n     * While scanning, wheels are rotated in opposite directions, giving a spin-rate for the \n     * selected power setting. Based on the axle-length and latest spin-rate, this function \n     * estimates the forward speed to be expected when using that power setting.\n     * (NOTE that tyre-friction or skidding when turning may make this a fairly inaccurate estimate!)\n     * \n     * @param axleLength : distance betweeen mid-lines of tyres (in mm)\n     * \n     * @return speed in mm-per-second, or error value:\n     * \n     *      -4 : SUCCESSFUL SCAN IS NEEDED FIRST\n     */\n    //% block=\"equivalent speed (mm/s), axle length (mm) = $axleLength\" \n    //% inlineInputMode=inline \n    //% weight=50 \n    export function equivalentSpeed(axleLength: number): number {\n        if (period < 0) {\n            return -4 // ERROR: SUCCESSFUL SCAN IS NEEDED FIRST\n        } else {\n            // compute tangential speed of wheel-centre in mm/s:\n            // it takes [period] ms to cover [2pi * axleLength/2] mm\n            return (Math.PI * axleLength * 1000 / period)\n        }\n    }\n\n\n    // UTILITY FUNCTIONS\n\n    /** Take the sum of several new readings to get a stable fix on the current heading.\n     *  @return the projected angle of the magnetic field-vector (in radians anticlockwise\n     * from the horizontal U-axis)\n     */\n\n    function takeSingleReading(): number {\n        let uRaw = 0\n        let vRaw = 0\n        let u = 0\n        let v = 0\n        let uNew = 0\n        let vNew = 0\n        let uFix = 0\n        let vFix = 0\n        let reading = 0\n        // get a new sample as the average of {Window} consecutive 2D readings, {SampleGap} apart\n        for (let i = 0; i < Window; i++) {\n            basic.pause(SampleGap)\n            uRaw += input.magneticForce(uDim)\n            vRaw += input.magneticForce(vDim)\n        }\n        uRaw /= Window\n        vRaw /= Window\n\n        // re-centre this latest point w.r.t our Ellipse origin\n        u = uRaw - uOff\n        v = vRaw - vOff\n\n        if (isCircular) {\n            reading = Math.atan2(v, u)\n        } else {\n            // Unless this Ellipse.isCircular, any {u,v} reading will be foreshortened in this View, and\n            // must be stretched along the Ellipse minor-axis to place it correctly onto the Spin-Circle.\n\n            // First rotate CLOCKWISE by theta (so aligning the Ellipse minor-axis angle with the V-axis)\n            uNew = u * cosTheta + v * sinTheta\n            vNew = v * cosTheta - u * sinTheta\n            // Now scale up along V, re-balancing the axes to make the Ellipse circular\n            uFix = uNew\n            vFix = vNew * scale\n            // get the adjusted angle for this corrected {u,v}\n            reading = Math.atan2(vFix, uFix)\n            // finally, undo the rotation by theta\n            reading += theta\n        }\n        return reading\n    }\n\n    /* Use vector addition to average a sequence of candidate axis Arrows (concievably empty!)\n    // The ones pointing away from the first one are assumed to belong to the other end\n    // of the axis, so will get reversed.\n    // The returned Arrow shows the average axis length and angle.\n    // Assuming candidates represent more than one revolution, the periodocity is also calculated.\n    */\n    function computeAxis(sheaf: Arrow[]): Arrow {\n        let result = new Arrow(0, 0, 0)\n        let turns = 0\n        let startTime = 0\n        let endTime = 0\n        let period = -1\n        let flipped = false\n        let uSum = 0\n        let vSum = 0\n        let rSum = 0\n        let count = sheaf.length\n        if (count > 0) {\n            // initialise axis as first (or only?) candidate\n            uSum = sheaf[0].u\n            vSum = sheaf[0].v\n            rSum = sheaf[0].size\n            let axis = sheaf[0].angle\n            startTime = sheaf[0].time\n            flipped = false\n            for (let i = 1; i < count; i++) {\n                // does next candidate point nearer the head or the tail of the axis?\n                if (Math.abs(angleSpan(axis, sheaf[i].angle)) < HalfPi) {\n                    // chain this candidate onto the emerging axis\n                    uSum += sheaf[i].u\n                    vSum += sheaf[i].v\n                    // the first unflipped candidate after one or more flipped ones clocks a new revolution\n                    if (flipped) {\n                        flipped = false\n                        turns++\n                        endTime = sheaf[i].time\n                    }\n                } else { // flip this arrow before chaining it, as it's pointing the \"wrong\" way\n                    flipped = true\n                    uSum -= sheaf[i].u\n                    vSum -= sheaf[i].v\n                }\n                // get the new blended angle\n                axis = Math.atan2(vSum, uSum)\n                rSum += sheaf[i].size\n            }\n\n            // build the result Arrow\n            result.size = rSum / count  // the average radius\n            result.angle = axis\n            result.u = result.size * Math.cos(axis)\n            result.v = result.size * Math.sin(axis)\n\n            // compute the average rotation time (so long as we've made at least one complete revolution)\n            if (endTime > 0) {\n                result.time = (endTime - startTime) / turns\n            }\n        }\n        // hijack the time property to return the estimated period\n        return result\n    }\n\n\n    /** gives the signed difference between angles a & b (allowing for roll-round)\n     * @param a first angle in radians\n     * @param b second angle in radians\n     * @returns the acute (i.e. smaller) difference in angle\n     */\n    function angleSpan(a: number, b: number) {\n        return ((ThreePi + b - a) % TwoPi) - Math.PI\n    }\n\n    // Convert an angle measured in radians to degrees.\n    function asDegrees(angle: number): number {\n        return ((angle * RadianDegrees) + 360) % 360\n    }\n}\n"}]},{"timestamp":1721491883794,"editorVersion":"7.0.13","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," \"*\""],[-1,",\n        \"pxt-heading\": \"workspace:23ae8b4e-fd30-4cfc-7934-39b860ebd793\""],[0,"\n   "]],"start1":139,"start2":139,"length1":81,"length2":8},{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":251,"start2":251,"length1":21,"length2":17}]}]},{"timestamp":1721543301173,"editorVersion":"7.0.13","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":324,"start2":324,"length1":17,"length2":21}]}]},{"timestamp":1721543430139,"editorVersion":"7.0.13","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"2"],[0,"0\" y=\""],[-1,"2"],[0,"0\"><"]],"start1":104,"start2":104,"length1":16,"length2":14},{"diffs":[[0,"e0=\"let "],[-1,"result"],[1,"spinRPM"],[0," = 0\" nu"]],"start1":245,"start2":245,"length1":22,"length2":23},{"diffs":[[0,"edvars=\""],[-1,"result"],[1,"spinRPM"],[0,"\"></muta"]],"start1":285,"start2":285,"length1":22,"length2":23},{"diffs":[[0,"tml\" line0=\"let "],[-1,"spinRPM"],[1,"result"],[0," = 0\" numlines=\""]],"start1":413,"start2":413,"length1":39,"length2":38},{"diffs":[[0,"\" declaredvars=\""],[-1,"spinRPM"],[1,"result"],[0,"\"></mutation><ne"]],"start1":452,"start2":452,"length1":39,"length2":38},{"diffs":[[0,"sk\"></mutation><"],[1,"comment pinned=\"false\" h=\"50\" w=\"50\">new mode, so always start with a scan</comment><"],[0,"next><block type"]],"start1":883,"start2":883,"length1":32,"length2":117},{"diffs":[[0,"=\"36"],[-1,"1"],[1,"6"],[0,"\" y=\""],[-1,"2"],[0,"0\"><"]],"start1":1247,"start2":1247,"length1":15,"length2":14},{"diffs":[[0,"tionid=\""],[-1,"kuGBiGbnq;{hUPB-]Or3"],[1,"[vA;:54=Q=ye][K9n$dl"],[0,"\"></muta"]],"start1":1383,"start2":1383,"length1":36,"length2":36},{"diffs":[[0,"=\"62"],[-1,"3"],[1,"8"],[0,"\" y=\""],[-1,"2"],[0,"0\"><"]],"start1":1487,"start2":1487,"length1":15,"length2":14},{"diffs":[[0,"tionid=\""],[-1,"R@84t::DXQ2#H72`|rg-"],[1,"(?z$N_d[_95s,b)]Uce3"],[0,"\"></muta"]],"start1":1618,"start2":1618,"length1":36,"length2":36},{"diffs":[[0,"x=\"8"],[-1,"86"],[1,"91"],[0,"\" y=\""],[-1,"2"],[0,"0\"><"]],"start1":1721,"start2":1721,"length1":16,"length2":15},{"diffs":[[0,"id=\""],[-1,"kuGBiGbnq;{hUPB-]Or3"],[1,"[vA;:54=Q=ye][K9n$dl"],[0,"\"></"]],"start1":1773,"start2":1773,"length1":28,"length2":28},{"diffs":[[0,"=\"17"],[-1,"55"],[1,"60"],[0,"\" y=\""],[-1,"2"],[0,"0\"><"]],"start1":4520,"start2":4520,"length1":16,"length2":15},{"diffs":[[0,"id=\""],[-1,"R@84t::DXQ2#H72`|rg-"],[1,"(?z$N_d[_95s,b)]Uce3"],[0,"\"></"]],"start1":4567,"start2":4567,"length1":28,"length2":28}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"}\n}\nlet "],[-1,"result"],[1,"spinRPM"],[0," = 0\nlet"]],"start1":3037,"start2":3037,"length1":22,"length2":23},{"diffs":[[0,"RPM = 0\nlet "],[-1,"spinRPM"],[1,"result"],[0," = 0\nenum Ta"]],"start1":3049,"start2":3049,"length1":31,"length2":30},{"diffs":[[0,"asure\n}\n"],[1,"// new mode, so always start with a scan\n"],[0,"let next"]],"start1":3114,"start2":3114,"length1":16,"length2":57}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":324,"start2":324,"length1":21,"length2":17}]}]},{"timestamp":1721573050729,"editorVersion":"7.0.13","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[1,"2"],[0,"0\" y=\""],[1,"2"],[0,"0\"><"]],"start1":104,"start2":104,"length1":14,"length2":16},{"diffs":[[0,"x=\"3"],[-1,"4"],[1,"6"],[0,"1\" y=\""],[1,"2"],[0,"0\"><"]],"start1":1163,"start2":1163,"length1":15,"length2":16},{"diffs":[[0,"x=\"6"],[-1,"0"],[1,"2"],[0,"3\" y=\""],[1,"2"],[0,"0\"><"]],"start1":1404,"start2":1404,"length1":15,"length2":16},{"diffs":[[0,"x=\"8"],[-1,"6"],[1,"8"],[0,"6\" y=\""],[1,"2"],[0,"0\"><"]],"start1":1640,"start2":1640,"length1":15,"length2":16},{"diffs":[[0,"=\"17"],[-1,"3"],[1,"5"],[0,"5\" y=\""],[1,"2"],[0,"0\"><"]],"start1":4440,"start2":4440,"length1":15,"length2":16}]}]},{"timestamp":1721573211388,"editorVersion":"7.0.13","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"\": \""],[-1,"github:grandpabond/pxt-heading#v1.1.2"],[1,"workspace:23ae8b4e-fd30-4cfc-7934-39b860ebd793"],[0,"\"\n  "]],"start1":165,"start2":165,"length1":45,"length2":54},{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":324,"start2":324,"length1":17,"length2":21}]}]},{"timestamp":1721627857416,"editorVersion":"7.0.13","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ime)"],[-1," if (result < 0) {\n                basic.showIcon(IconNames.Skull) // problem with scan data analysis\n                basic.pause(1000)\n                basic.showNumber(result)\n                basic.pause(1000)\n                basic.clearScreen()\n                basic.showArrow(ArrowNames.West)\n                nextTask = Task.Scan // restart with a fresh scan\n            } else {"],[0,"\n   "]],"start1":303,"start2":303,"length1":390,"length2":8},{"diffs":[[0,"        "],[1," if (result < 0) {\n                basic.showIcon(IconNames.Skull) // problem with scan data analysis\n                basic.pause(1000)\n                basic.showNumber(result)\n                basic.pause(1000)\n                basic.clearScreen()\n                basic.showArrow(ArrowNames.West)\n                nextTask = Task.Scan // restart with a fresh scan\n            } else {"],[0,"\n       "]],"start1":681,"start2":681,"length1":16,"length2":398}]}]},{"timestamp":1721628129315,"editorVersion":"7.0.13","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"nTime = "],[-1,"5"],[1,"6"],[0,"000 // ."]],"start1":94,"start2":94,"length1":17,"length2":17},{"diffs":[[0,"\n           "],[-1," result ="],[0," heading.sca"]],"start1":263,"start2":263,"length1":33,"length2":24},{"diffs":[[0,"canTime)"],[-1,"\n           "],[0," if (res"]],"start1":299,"start2":299,"length1":28,"length2":16},{"diffs":[[0,"ime) if (result "],[-1,"=="],[1,"<"],[0," 0) {\n          "]],"start1":303,"start2":303,"length1":34,"length2":33},{"diffs":[[0,"mes."],[-1,"Yes)\n                nextTask = Task.SetNorth\n            } else {\n                basic.showIcon(IconNames.Skull) // problem with scan data analysis"],[1,"Skull) // problem with scan data analysis\n                basic.pause(1000)\n                basic.showNumber(result)\n                basic.pause(1000)"],[0,"\n   "]],"start1":363,"start2":363,"length1":157,"length2":158},{"diffs":[[0,"      basic."],[-1,"pause(1000"],[1,"clearScreen("],[0,")\n          "]],"start1":528,"start2":528,"length1":34,"length2":36},{"diffs":[[0,"show"],[-1,"Number(result)\n            }"],[1,"Arrow(ArrowNames.West)\n                nextTask = Task.Scan // restart with a fresh scan\n            } else {\n            basic.showIcon(IconNames.Yes)"],[0,"\n   "]],"start1":576,"start2":576,"length1":36,"length2":159},{"diffs":[[0,"rrowNames.West)\n"],[1,"            nextTask = Task.SetNorth\n"],[0,"            brea"]],"start1":823,"start2":823,"length1":32,"length2":69},{"diffs":[[0,"North()\n"],[1,"\n"],[0,"        "]],"start1":1051,"start2":1051,"length1":16,"length2":17},{"diffs":[[0,"    "],[-1," if (result == 0) {"],[0,"\n   "]],"start1":1067,"start2":1067,"length1":27,"length2":8}]}]},{"timestamp":1721629567488,"editorVersion":"7.0.13","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"art\""],[-1," id=\"r|RBna$Y+LwQ[TPAEUbQ\""],[0," x=\""]],"start1":100,"start2":100,"length1":34,"length2":8},{"diffs":[[0,"ent\""],[-1," id=\"H?@@;Xb$;9mN=u_?W?*F\""],[0," edi"]],"start1":173,"start2":173,"length1":34,"length2":8},{"diffs":[[0,"ent\""],[-1," id=\"A{Vn^Nl)4LUL;9.p.OCG\""],[0," edi"]],"start1":347,"start2":347,"length1":34,"length2":8},{"diffs":[[0,"ent\""],[-1," id=\"X%eChh!?x)gC!Jzk3Xmo\""],[0," edi"]],"start1":523,"start2":523,"length1":34,"length2":8},{"diffs":[[0,"ent\""],[-1," id=\"nV^5k},+R2l-qCfj#CZ}\""],[0," edi"]],"start1":742,"start2":742,"length1":34,"length2":8},{"diffs":[[0,"row\""],[-1," id=\"sN-Xke6_=HVsyQAt=ev-\""],[0,"><va"]],"start1":930,"start2":930,"length1":34,"length2":8},{"diffs":[[0,"row\""],[-1," id=\"H9JsB~s{fuGfuoDSsj6U\""],[0,"><fi"]],"start1":974,"start2":974,"length1":34,"length2":8},{"diffs":[[0,"ent\""],[-1," id=\".^z3:vQ(uX?:oE=nIt-L\""],[0," x=\""]],"start1":1156,"start2":1156,"length1":34,"length2":8},{"diffs":[[0,"all\""],[-1," id=\"i.S#+@yxj?Ch[+HHf.l*\""],[0,"><mu"]],"start1":1259,"start2":1259,"length1":34,"length2":8},{"diffs":[[0,"ent\""],[-1," id=\"bzVj]x#8FPBa=(Zl#x{i\""],[0," x=\""]],"start1":1396,"start2":1396,"length1":34,"length2":8},{"diffs":[[0,"all\""],[-1," id=\"[qO_q!woOpG]rJn5~V$^\""],[0,"><mu"]],"start1":1499,"start2":1499,"length1":34,"length2":8},{"diffs":[[0,"ion\""],[-1," id=\"s8D.8OkD-jj*+SgZ?gP.\""],[0," x=\""]],"start1":1631,"start2":1631,"length1":34,"length2":8},{"diffs":[[0,"ent\""],[-1," id=\"(Pg.gE[L5ELdwCfZ3#[+\""],[0," edi"]],"start1":1827,"start2":1827,"length1":34,"length2":8},{"diffs":[[0,"ion\""],[-1," id=\",{f9]YPhS7b92;A0R{4B\""],[0," x=\""]],"start1":4429,"start2":4429,"length1":34,"length2":8},{"diffs":[[0,"ent\""],[-1," id=\"yreNCA8+8#{$MS`.vrk=\""],[0," edi"]],"start1":4616,"start2":4616,"length1":34,"length2":8}]}]},{"timestamp":1721629567512,"editorVersion":"7.0.13","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":295,"start2":295,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1720100563660,"editorVersion":"7.0.13","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"heading test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1721227065354,"editorVersion":"7.0.13","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"// tests go here; this will not be compiled when this package is used as an extension.\nenum Task {\n    Scan,\n    SetNorth,\n    Measure\n}\nfunction performSetup() {\n    let result = 0\n    switch (nextTask) {\n        case Task.Scan:\n            let scanTime = 6000 // ...to MANUALLY rotate turntable jig twice (SMOOOOTHLY!)\n            basic.showString(\"S\")\n            basic.pause(1000)\n            basic.showString(\"_\")\n            heading.scanClockwise(scanTime)\n            basic.showIcon(IconNames.Yes)\n            basic.pause(1000)\n            basic.clearScreen()\n            basic.showArrow(ArrowNames.West)\n            nextTask = Task.SetNorth\n            break\n\n        case Task.SetNorth:\n            basic.showString(\"N\")\n            basic.pause(1000)\n            basic.clearScreen()\n            result = heading.setNorth()\n\n            if (result < 0) {\n                basic.showIcon(IconNames.Skull) // problem with scan data analysis\n                basic.pause(1000)\n                basic.showNumber(result)\n                basic.pause(1000)\n                basic.clearScreen()\n                basic.showArrow(ArrowNames.West)\n                nextTask = Task.Scan // restart with a fresh scan\n            } else {\n                spinRPM = heading.spinRate() // ...just out of interest\n                basic.showNumber(Math.floor(spinRPM))\n                basic.pause(1000)\n                basic.showIcon(IconNames.Yes)\n                basic.pause(500)\n                basic.showLeds(`\n                    # # . # #\n                    # . . . #\n                    . . # . .\n                    # . . . #\n                    # # . # #\n                    `)\n                basic.pause(500)\n                basic.showArrow(ArrowNames.East)\n                nextTask = Task.Measure\n            }\n            break\n\n        case Task.Measure: // Button A allows new North setting\n            basic.showIcon(IconNames.No)\n            basic.pause(1000)\n            basic.clearScreen()\n            basic.showArrow(ArrowNames.West)\n            nextTask = Task.SetNorth // reset new North\n            break\n    }\n\n}\n\nfunction measure() {\n    switch (nextTask) {\n        // ? sequence error?\n        case Task.SetNorth:\n        case Task.Scan: // use button A to do a scan first\n            for (let i = 0; i < 5; i++) {\n                basic.clearScreen()\n                basic.pause(100)\n                basic.showArrow(ArrowNames.West)\n            }\n            break\n\n        case Task.Measure: // OK, take a new heading measurement\n            basic.pause(200)\n            basic.clearScreen()\n            basic.pause(50)\n            let compass = heading.degrees()\n            basic.showNumber(Math.floor(compass))\n            basic.pause(500)\n            // now MANUALLY move to next test-angle...\n            basic.showLeds(`\n                    # # . # #\n                    # . . . #\n                    . . . . .\n                    # . . . #\n                    # # . # #\n                    `)\n            basic.pause(200)\n            break\n    }\n\n}\n\ninput.onButtonPressed(Button.A, function () {\n    performSetup()\n})\n\ninput.onButtonPressed(Button.B, function () {\n    measure()\n})\n\nlet nextTask: Task = Task.Scan // new mode, so always start with a scan\nlet spinRPM = 0\nbasic.showArrow(ArrowNames.West)\n","README.md":"","pxt-heading.ts":"\n// TODO? No use is yet made of the accelerometer. Although seemingly helpful to compensate for\n// static tilt, on a moving buggy dynamic sideways accelerations confound the measurement of \"down\",\n// so applying tilt-compensation could actually make compass-heading accuracy worse!\n\n\n\n//% color=#6080e0 weight=40 icon=\"\\uf14e\" block=\"Heading\" \n/**\n * An extension providing a compass-bearing for a buggy located anywhere on the globe \n * (except at the magnetic poles!), with any arbitrary mounting orientation for its microbit.\n * \n * See the README for a detailed description of the approach, methods and algorithms.\n */\nnamespace heading {\n\n    // ENUMERATIONS\n    enum View { // the axis-pairs that span the three possible magnetometer projection planes\n        XY,\n        YZ,\n        ZX\n    }\n\n    // CONSTANTS\n\n    const HalfPi = Math.PI / 2\n    const TwoPi = 2 * Math.PI\n    const ThreePi = 3 * Math.PI\n    const RadianDegrees = 360 / TwoPi\n    const EnoughScanTime = 1500 // minimum acceptable scan-time\n    const EnoughSamples = 70 // fewest acceptable scan samples\n    const TooManySamples = 500 // don't be too greedy with memory!\n    const MarginalField = 10 // minimum acceptable field-strength for magnetometer readings\n    const Circular = 1.03 // maximum eccentricity to consider an Ellipse as \"circular\" (3% gives ~1 degree error)\n    const NearEnough = 0.75 // major-axis candidates must be longer than (longest*NearEnough)\n    // minor-axis candidates must be shorter than (shortest/NearEnough) \n    const Window = 8 // number of magnetometer samples needed to form a good average\n    const SampleGap = 15 // minimum ms to wait between magnetometer readings\n    const AverageGap = 25 // (achieved in practice, due to system interrupts)\n    const Latency = Window * AverageGap // consequent time taken to collect a good moving average from scratch\n\n    // SUPPORTING CLASSES\n\n    // An Arrow is an object holding a directed vector {u,v} in both Cartesian and Polar coordinates. \n    // It also carries a time-field, used to timestamp scanned samples.\n    // An Arrow is used to hold a 2D magnetometer measurement as a re-centred vector.\n\n    class Arrow {\n        u: number; // horizontal component\n        v: number; // vertical component\n        size: number; // polar magnitude of vector\n        angle: number; // polar angle (radians anticlockwise from East)\n        time: number; // for scan samples, timestamp of when this was collected\n\n        constructor(u: number, v: number, t: number) {\n            this.u = u\n            this.v = v\n            this.size = Math.sqrt((u * u) + (v * v))\n            this.angle = 0\n            if (this.size > 0) { // defend against zero-divide\n                this.angle = Math.atan2(v, u)\n            }\n            this.time = t\n        }\n        // when copying...\n        cloneMe(): Arrow {\n            return new Arrow(this.u, this.v, this.time)\n        }\n    }\n\n    // A Smoother object computes a moving average from a sequence of time-stamped values: \n    // in our case, magnetometer readings and their derivatives.\n    // Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n    // The constant {Window} governs the latency of the exponential averaging process.\n    // Smoothers can work with arbitrary-sized vectors of values that share the same timestamp.\n    // history[], previous[], latest[] and result[] arrays will be either 3-D, (for initial [X,Y,Z] scanning)\n    // or 2-D, (for analysing chosen the [uDim,vDim]).\n    class Smoother {\n        dims: number; // dimensionality\n        average: number[] = []; // \n        lastTime: number;\n        lastInputs: number[] = [];\n\n        constructor(first: number[], start: number) {\n            this.dims = first.length\n            this.lastTime = start\n            for (let i = 0; i < this.dims; i++) {\n                this.average.push(first[i])\n                this.lastInputs.push(first[i])\n            }\n        }\n\n        update(values: number[], timeStamp: number): number[] {\n            // work out appropriate blend, based on time-step\n            let timeFraction = (timeStamp - this.lastTime) / Latency\n            let keepOld = Math.exp(-timeFraction)\n            let inherited = (1 - keepOld) / timeFraction\n            // we amplify the most recent sample's contribution to the inherited average\n            let boostLast = (inherited - keepOld)\n            let addNew = (1 - inherited)\n            // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n            // apply blending to all elements of old and new data arrays\n            let result: number[] = []\n            for (let i = 0; i < this.dims; i++) {\n                result.push(keepOld * this.average[i]\n                    + boostLast * this.lastInputs[i]\n                    + addNew * values[i])\n            }\n            // update history for next time around\n            this.lastTime = timeStamp\n            this.average = result\n            this.lastInputs = values\n\n            return result\n        }\n    }\n\n\n    // An Ellipse is an object holding the characteristics of the (typically) elliptical\n    // view formed when projecting the scan Spin-Circle onto a 2-axis View-plane.\n    class Ellipse {\n        plane: string; // View name (just for debug)\n        uDim: number; // horizontal axis of this View\n        vDim: number; // vertical axis of this View\n        uOff: number; // horizontal offset needed to re-centre this Ellipse along the U-axis\n        vOff: number; // vertical offset needed to re-centre this Ellipse along the V-axis\n\n        // calibration characteristics\n        majorAngle: number; // direction of the Ellipse major axis \n        period: number; // scan-rotation time as viewed in this plane\n        eccentricity: number; // ratio of major-axis to minor-axis magnitudes for this Ellipse\n        isCircular: boolean; // flag saying this \"Ellipse\" View is almost circular, simplifying future handling\n        rotationSense: number; // rotation reversal sign = +/-1, reflecting this Ellipse's view of the clockwise scan\n\n        constructor(plane: string, uDim: number, vDim: number, uOff: number, vOff: number) {\n            this.plane = plane // (as a DEBUG aid)\n            this.uDim = uDim\n            this.vDim = vDim\n            this.uOff = uOff\n            this.vOff = vOff\n            this.isCircular = false // until proved otherwise!\n            this.period = -1\n        }\n\n        // This method analyses a 2-D subset of the scanData for a projected View of the Spin-Circle,\n        // creating an Arrow indicating the major-axis direction of the elliptical View.\n        // It performs several tasks:\n        // 1) By comparing the longest and shortest radii, this method works out the eccentricity of \n        //    the Ellipse, as seen from this View. Also notes whether being viewed \"from below\".\n        // 2) It collects possible candidates for the Ellipse major and minor axes by looking for local \n        //    radius peaks and troughs; candidate values are pushed onto two lists of Arrows:\n        //    this.majors[] and this.minors[]\n        // 3) These lists are then carefully assessed to evolve a consensus for the two axes. \n        //    For \"pointy\" Ellipses we get a single candidate each time we pass either end of the axis.\n        //    For \"rounder\" Ellipses each transit may deliver multiple candidates. If a candidate points \n        //    closer to the head of the ongoing mean, it is added in; if it points closer to the tail, \n        //    then it's inverse is added in (as it must \"belong\" to the other end of the axis).\n        // 4) As we do this, we work out the rotation period by clocking each time we flip ends of the axis.\n        // 5) All this analysis results in a single Arrow for each axis which can be averaged (after turning\n        //    the minor axis through a right-angle)\n\n\n        analyseView() {\n            let majors: Arrow[] = [] // candidate directions for major axis of Ellipse\n            let minors: Arrow[] = [] // candidate directions for minor axis of Ellipse\n            let major: Arrow = new Arrow(0, 0, 0)\n            let minor: Arrow = new Arrow(0, 0, 0)\n            let longest = 0\n            let shortest = 99999\n            let spin = 0\n            let sizeWas: number\n            let angleWas: number\n            let step: number = 99999 // marker for \"first time round\"\n            let stepWas: number\n            // extract coordinates of the first point lying in this.plane\n            let point = [scanData[0][this.uDim], scanData[0][this.vDim]]\n            // set up a 2D Smoother for points on this Ellipse\n            let curve = new Smoother(point, scanTimes[0])\n            // compare first one with remaining samples\n            let trial = new Arrow(point[0], point[1], scanTimes[0])\n            for (let i = 1; i < scanTimes.length; i++) {\n                sizeWas = trial.size\n                angleWas = trial.angle\n                // blend the next point into the moving average\n                point = curve.update([scanData[i][this.uDim], scanData[i][this.vDim]], scanTimes[i])\n                trial = new Arrow(point[0], point[1], scanTimes[i])\n\n                // accumulate gradual rotation of the projected field-vector...\n                let delta = trial.angle - angleWas\n                spin += delta\n                // fix roll-rounds in either direction\n                if (delta > HalfPi) spin -= TwoPi // apparent big positive jump is due to underflow\n                if (delta < -HalfPi) spin += TwoPi // apparent big negative jump is due to overflow\n\n                // now collect candidates for axes  \n                stepWas = step\n                step = trial.size - sizeWas // is radius growing or shrinking (or the same!)?\n                if (stepWas == 99999) stepWas = step // (ensure that the first two steps will always match)\n                if (step == 0) step = stepWas // ignore any (rare!) static sequence by propagating last step\n\n                // look for peaks, where we switch from growing to shrinking\n                if ((stepWas > 0) && (step < 0)) {\n                    longest = Math.max(longest, trial.size)\n                    majors.push(trial.cloneMe()) // copy the major axis we are passing\n                }\n\n                // look for troughs, where we switch from shrinking to growing\n                if ((stepWas < 0) && (step > 0)) {\n                    shortest = Math.min(shortest, trial.size)\n                    minors.push(trial.cloneMe()) // copy the minor axis we are passing\n                }\n\n            }\n            // During a clockwise scan, the projection-angle of the field-vector as viewed from above \n            // will appear to rotate anticlockwise (increasing radians) from the perspective of the Buggy. \n            // If we find it rotates clockwise (decreasing radians) then this projection-plane must be \n            // viewing the field-vector from below.\n            this.rotationSense = spin / Math.abs(spin) // == -1 if viewing from below\n\n            /* PERIODICITY FROM SPIN?\n             Why not simply use the accumulated spin-angle and time-span to calculate the rotation-period?\n             --Because the arbitrary start and end angles may be subject to fore-shortening, and hence\n             quite inaccurate! The only dependable angles occur just as we pass over the axes (see below).\n            */\n\n\n            /* We are trying to find a good approximation to the tilt of the Ellipse's major-axis.  \n            We could simply nominate the longest candidate detected, but instead we will average them.\n\n            If the Ellipse is quite eccentric, it will yield neatly alternating candidates with \n            \"opposite\" angles.passing the major-axis twice per Spin-circle revolution \n\n            With a more-nearly circular Ellipse, noisy readings can yield alternating clusters of local maxima \n            gathered near each end of the axis.\n\n            An almost circular Ellipse has no meaningful axis and generally yields multiple spurious candidates. \n            */\n\n            // purge any local maximum whose vector length is too short --it's nowhere near the major-axis!\n            let long = longest * NearEnough\n            for (let i = 0; i < majors.length; i++) {\n                if (majors[i].size < long) {\n                    majors.splice(i, 1)  // disqualified!\n                    i-- // (all subsequent candidates now shuffle up by one place!)\n                }\n            }\n\n            // similarly purge all errant local minima that are too big\n            let short = shortest / NearEnough\n            for (let i = 0; i < minors.length; i++) {\n                if (minors[i].size > short) {\n                    minors.splice(i, 1)\n                    i--\n                }\n            }\n\n\n            // form consensus averages of the two ends of the two axes\n            major = computeAxis(majors)\n            minor = computeAxis(minors)\n\n            // average the axis angles carefully: minor axis is always orthgonal, but phase may lead or follow!\n            let minorTurned = minor.angle + HalfPi // assume it leads by 90 degrees\n            if (angleSpan(major.angle, minor.angle) > 0) {\n                minorTurned += Math.PI // no: it follows, so add another 180 degrees\n            }\n            // use the average of the two angles\n            this.majorAngle = ((major.angle + minorTurned) / 2) % TwoPi\n            // The ratio of the axis lengths gives the eccentricity of this Ellipse\n            this.eccentricity = major.size / minor.size\n            // average the periodicities detected \n            this.period = (major.time + minor.time) / 2\n            // Readings on a near-circular Ellipse won't ever be fore-shortened, so we can skip correction!\n            this.isCircular = (this.eccentricity < Circular)\n        }\n    }\n\n\n\n    // GLOBALS\n\n    let scanTimes: number[] = [] // sequence of time-stamps for scanned readings \n    let scanData: number[][] = [] // scanned sequence of [X,Y,Z] magnetometer readings\n    let scanTime: number = 0 // duration of scan in ms\n    let views: Ellipse[] = [] // the three possible elliptical views of the Spin-Circle\n    let bestView = -1\n    let uDim = -1 // the \"horizontal\" axis (called U) for the best View\n    let vDim = -1 // the \"vertical\" axis (called V) for the best View\n    let north = 0 // reading registered as \"North\"\n    let strength = 0 // the average magnetic field-strength observed by the magnetometer\n    let period = -1 // overall assessment of average rotation time\n\n    // correction parameters adopted from bestView Ellipse for future readings\n    let rotationSense = 1 // set to -1 if orientation means field-vector projection is \"from below\"\n    let isCircular: boolean // if bestView Ellipse is circular, no correction is needed\n    let uOff: number // horizontal origin offset\n    let vOff: number // vertical origin offset\n    let theta: number  // major-axis tilt angle (in radians anticlockwise from the U-axis)\n    let cosTheta: number; // saved for efficiency\n    let sinTheta: number; //      ditto\n    let scale: number // stretch-factor for correcting foreshortened readings (= eccentricity)\n\n    // EXPORTED USER INTERFACES   \n\n    /** \n     * Assuming the buggy is currently spinning clockwise on the spot, capture a \n     * time-stamped sequence of magnetometer readings from which to set up the compass.\n     *\n     * @param ms scanning-time in millisecs (long enough for more than one full rotation)    \n     */\n\n    //% block=\"scan clockwise for (ms) $ms\" \n    //% inlineInputMode=inline \n    //% ms.shadow=\"timePicker\" \n    //% ms.defl=0 \n    //% weight=90 \n\n    export function scanClockwise(ms: number) {\n        // Sample magnetometer readings periodically over the specified duration (generally a couple\n        // of seconds), and append a new [X,Y,Z] triple to the scanData[] array.\n        // A timestamp for each sample is also recorded in the scanTimes[] array.\n\n        // NOTE: To smooth out jitter, each reading is always a moving average of several consecutive readings.\n        // Because sample-times may be irregular (due to scheduled interrupts), a Smoother is used to provide\n        // a timing-aware exponential moving-average. The sample-grouping and spacing are controlled \n        // respectively by the constants Window and SampleGap, which together determine the Latency.\n\n        scanTimes = []\n        scanData = []\n        let index = 0\n\n        let timeWas: number\n        let timeNow: number\n        let fresh: number[] = []\n        let updated: number[] = []\n\n        basic.pause(200) // wait for motors to stabilise (after initial kick)\n        // get initial reading\n        let timeStamp = input.runningTime()\n        fresh = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n        // use a Smoother to maintain a rolling average\n        let scan = new Smoother(fresh, timeStamp)\n\n        // after an initial settling period, continue cranking out updated moving averages \n        let startTime = timeStamp + Latency\n        let stopTime = timeStamp + ms\n\n        // until we run out of time (or space!)\n        while ((timeStamp < stopTime)\n            && (scanTimes.length < TooManySamples)) {\n            // After processing, sleep until it's time for next sample.\n            // NOTE: here is where various system subprograms will get scheduled.\n            // If they need more time than we've offered, out next sample will get delayed!\n            // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n            timeWas = timeStamp // remember time of latest sample\n            timeNow = input.runningTime()\n            basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n            timeStamp = input.runningTime() // take a fresh set of readings\n\n            fresh = [\n                input.magneticForce(Dimension.X),\n                input.magneticForce(Dimension.Y),\n                input.magneticForce(Dimension.Z)]\n            updated = scan.update(fresh, timeStamp)\n\n            // only start recording once the moving average has stabilised\n            if (timeStamp > startTime) {\n                // store the triple of averaged [X,Y,Z] values (as a deep copy!)\n                scanData.push([updated[0], updated[1], updated[2]])\n                scanTimes.push(timeStamp)  // timestamp it\n                index++\n            }\n        }\n    }\n\n    /**\n     * Analyse the scanned data to prepare for reading compass-bearings.\n     * Then read the magnetometer and register the buggy's current direction as \"North\",\n     * (i.e. the direction that will in future return zero as its heading).\n     * \n     * The actual direction of the buggy when this function is called is arbitrary:\n     * it could be Magnetic North; or True North (compensating for local declination); \n     * or any convenient direction from which to measure subsequent heading angles.\n     * \n     * @return zero if successful, or a negative error code:\n     *\n     *      -1 : NOT ENOUGH SCAN DATA\n\n     *      -2 : FIELD STRENGTH TOO WEAK\n     *\n     *      -3 : NOT ENOUGH SCAN ROTATION\n     *\n     */\n    //% block=\"set North\" \n    //% inlineInputMode=inline \n    //% weight=80 \n    export function setNorth(): number {\n        // reset global defaults\n        bestView = -1\n        strength = -1\n        period = -1\n\n        // First analyse the scan-data to decide how best to use the magnetometer readings.\n        // we'll typically need about a couple of second's worth of scanned readings...\n        let nSamples = scanTimes.length\n        scanTime = scanTimes[nSamples - 1] - scanTimes[0]\n\n        if ((nSamples < EnoughSamples) || (scanTime < EnoughScanTime)) {\n            return -1 // \"NOT ENOUGH SCAN DATA\"\n        }\n        // Each dimension should track a sinusoidal wave of values (generally not centred on zero).\n        // The first pass finds the ranges for each axis \n        let xlo = 9999999\n        let ylo = 9999999\n        let zlo = 9999999\n        let xhi = -9999999\n        let yhi = -9999999\n        let zhi = -9999999\n        for (let i = 0; i < nSamples; i++) {\n            xhi = Math.max(xhi, scanData[i][Dimension.X])\n            yhi = Math.max(yhi, scanData[i][Dimension.Y])\n            zhi = Math.max(zhi, scanData[i][Dimension.Z])\n            xlo = Math.min(xlo, scanData[i][Dimension.X])\n            ylo = Math.min(ylo, scanData[i][Dimension.Y])\n            zlo = Math.min(zlo, scanData[i][Dimension.Z])\n        }\n\n        // get RMS field-strength\n        let xField = (xhi - xlo) / 2\n        let yField = (yhi - ylo) / 2\n        let zField = (zhi - zlo) / 2\n        strength = Math.sqrt((xField * xField) + (yField * yField) + (zField * zField))\n\n        // Bail out early if the scan didn't properly detect the Earth's magnetic field,\n        // (perhaps due to magnetic shielding)\n        if (strength < MarginalField) {\n            return -2 // \"FIELD STRENGTH TOO WEAK\"\n        }\n        // The means of the extremes give an approximation to the central offsets.\n        let xOff = (xhi + xlo) / 2\n        let yOff = (yhi + ylo) / 2\n        let zOff = (zhi + zlo) / 2\n\n        // re-centre all of the scanData samples, so eliminating \"hard-iron\" magnetic effects\n        for (let i = 0; i < nSamples; i++) {\n            scanData[i][Dimension.X] -= xOff\n            scanData[i][Dimension.Y] -= yOff\n            scanData[i][Dimension.Z] -= zOff\n        }\n\n        // create three Ellipse instances for analysing each possible view in turn\n        views.push(new Ellipse(\"XY\", Dimension.X, Dimension.Y, xOff, yOff))\n        views.push(new Ellipse(\"YZ\", Dimension.Y, Dimension.Z, yOff, zOff))\n        views.push(new Ellipse(\"ZX\", Dimension.Z, Dimension.X, zOff, xOff))\n\n        // For each View, perform the analysis of eccentricity and Ellipse tilt-angle\n        views[View.XY].analyseView()\n        views[View.YZ].analyseView()\n        views[View.ZX].analyseView()\n\n        // check that at least one View saw at least one complete rotation (with a measurable period)...\n        if ((views[View.XY].period == -1)\n            && (views[View.YZ].period == -1)\n            && (views[View.ZX].period == -1)) {\n            return -3 // \"NOT ENOUGH SCAN ROTATION\"\n        }\n\n        // Choose the \"roundest\" Ellipse  --the one with lowest eccentricity.\n        bestView = View.XY\n        if (views[View.YZ].eccentricity < views[bestView].eccentricity) bestView = View.YZ\n        if (views[View.ZX].eccentricity < views[bestView].eccentricity) bestView = View.ZX\n\n        // periodicity is unreliable in a near-circular View: average just the other two Views' measurements\n        period = (views[0].period + views[1].period + views[2].period - views[bestView].period) / 2\n\n        // For efficiency, extract various characteristics from our adopted \"bestView\" Ellipse\n        uDim = views[bestView].uDim\n        vDim = views[bestView].vDim\n        uOff = views[bestView].uOff\n        vOff = views[bestView].vOff\n        scale = views[bestView].eccentricity // scaling needed to balance axes\n        theta = views[bestView].majorAngle // the rotation (in radians) of the major-axis from the U-axis\n        cosTheta = Math.cos(theta)\n        sinTheta = Math.sin(theta)\n        isCircular = views[bestView].isCircular\n        rotationSense = views[bestView].rotationSense\n\n        // Having successfully set up the projection parameters for the bestView, get a\n        // stable fix on the current heading, which we will then designate as \"North\".\n        // (This is the global fixed bias to be subtracted from all future readings)\n        north = takeSingleReading()\n\n        // we've now finished with the scanning data and Ellipse objects, so release their memory\n        scanTimes = []\n        scanData = []\n        views = []\n\n        // SUCCESS!\n        return 0\n    }\n\n\n    /**\n     * Read the magnetometer\n     * \n     * @return the current heading of the buggy\n     * \n     * (in degrees clockwise, relative to \"North\")\n     */\n    //% block=\"degrees\" \n    //% inlineInputMode=inline \n    //% weight=70\n    export function degrees(): number {\n        // Depending on mounting orientation, the bestView might possibly be seeing the Spin-Circle from\n        // \"underneath\", with the field-vector appearing to move clockwise  --effectively experiencing an\n        // anti-clockwise scan. In this case the rotationSense will be negative.\n        return asDegrees((takeSingleReading() - north) * rotationSense)\n        // NOTE: that there is a double reversal going on here:\n        // Viewed from above, the Field-vector reading in radians INCREASES (anticlockwise) w.r.t \"North\"\n        // as the buggy's compass-heading INCREASES (clockwise).\n        // So after a right-turn while facing North, the reading is HalfPi bigger than the North reading.\n        // After subtracting North (cyclically), that converts asDegrees() to +90 \n        // From below (when rotationSense = -1), the same right-turn would DECREASE the reading by HalfPi\n        // necessitating a third reversal (after first subtracting North) !\n    }\n\n    /**\n     * The average rotation time of the most recent scan \n     * @return rotation time, or error-value:\n     * \n     *      -4 : SUCCESSFUL SCAN IS NEEDED FIRST\n     */\n    //% block=\"spin time (ms)\" \n    //% inlineInputMode=inline \n    //% weight=60 \n    export function spinTime(): number {\n        if (period == -1) {\n            return -4 // ERROR: SUCCESSFUL SCAN IS NEEDED FIRST\n        } else {\n            return period\n        }\n    }\n\n    /**\n     * The average rotation rate of the most recent scan \n     * \n     * @return revs-per-minute, or error value:\n     * \n     *      -4 : SUCCESSFUL SCAN IS NEEDED FIRST\n     */\n    //% block=\"spin rate (RPM)\" \n    //% inlineInputMode=inline \n    //% weight=50 \n    export function spinRate(): number {\n        if (period == -1) {\n            return -4 // ERROR: SUCCESSFUL SCAN IS NEEDED FIRST\n        } else {\n            return 60000 / period\n        }\n    }\n\n    /**\n     * While scanning, wheels are rotated in opposite directions, giving a spin-rate for the \n     * selected power setting. Based on the axle-length and latest spin-rate, this function \n     * estimates the forward speed to be expected when using that power setting.\n     * (NOTE that tyre-friction or skidding when turning may make this a fairly inaccurate estimate!)\n     * \n     * @param axleLength : distance betweeen mid-lines of tyres (in mm)\n     * \n     * @return speed in mm-per-second, or error value:\n     * \n     *      -4 : SUCCESSFUL SCAN IS NEEDED FIRST\n     */\n    //% block=\"equivalent speed (mm/s), axle length (mm) = $axleLength\" \n    //% inlineInputMode=inline \n    //% weight=50 \n    export function equivalentSpeed(axleLength: number): number {\n        if (period < 0) {\n            return -4 // ERROR: SUCCESSFUL SCAN IS NEEDED FIRST\n        } else {\n            // compute tangential speed of wheel-centre in mm/s:\n            // it takes [period] ms to cover [2pi * axleLength/2] mm\n            return (Math.PI * axleLength * 1000 / period)\n        }\n    }\n\n\n    // UTILITY FUNCTIONS\n\n    /** Take the sum of several new readings to get a stable fix on the current heading.\n     *  @return the projected angle of the magnetic field-vector (in radians anticlockwise\n     * from the horizontal U-axis)\n     */\n\n    function takeSingleReading(): number {\n        let uRaw = 0\n        let vRaw = 0\n        let u = 0\n        let v = 0\n        let uNew = 0\n        let vNew = 0\n        let uFix = 0\n        let vFix = 0\n        let reading = 0\n        // get a new sample as the average of {Window} consecutive 2D readings, {SampleGap} apart\n        for (let i = 0; i < Window; i++) {\n            basic.pause(SampleGap)\n            uRaw += input.magneticForce(uDim)\n            vRaw += input.magneticForce(vDim)\n        }\n        uRaw /= Window\n        vRaw /= Window\n\n        // re-centre this latest point w.r.t our Ellipse origin\n        u = uRaw - uOff\n        v = vRaw - vOff\n\n        if (isCircular) {\n            reading = Math.atan2(v, u)\n        } else {\n            // Unless this Ellipse.isCircular, any {u,v} reading will be foreshortened in this View, and\n            // must be stretched along the Ellipse minor-axis to place it correctly onto the Spin-Circle.\n\n            // First rotate CLOCKWISE by theta (so aligning the Ellipse minor-axis angle with the V-axis)\n            uNew = u * cosTheta + v * sinTheta\n            vNew = v * cosTheta - u * sinTheta\n            // Now scale up along V, re-balancing the axes to make the Ellipse circular\n            uFix = uNew\n            vFix = vNew * scale\n            // get the adjusted angle for this corrected {u,v}\n            reading = Math.atan2(vFix, uFix)\n            // finally, undo the rotation by theta\n            reading += theta\n        }\n        return reading\n    }\n\n    /* Use vector addition to average a sequence of candidate axis Arrows (concievably empty!)\n    // The ones pointing away from the first one are assumed to belong to the other end\n    // of the axis, so will get reversed.\n    // The returned Arrow shows the average axis length and angle.\n    // Assuming candidates represent more than one revolution, the periodocity is also calculated.\n    */\n    function computeAxis(sheaf: Arrow[]): Arrow {\n        let result = new Arrow(0, 0, 0)\n        let turns = 0\n        let startTime = 0\n        let endTime = 0\n        let period = -1\n        let flipped = false\n        let uSum = 0\n        let vSum = 0\n        let rSum = 0\n        let count = sheaf.length\n        if (count > 0) {\n            // initialise axis as first (or only?) candidate\n            uSum = sheaf[0].u\n            vSum = sheaf[0].v\n            rSum = sheaf[0].size\n            let axis = sheaf[0].angle\n            startTime = sheaf[0].time\n            flipped = false\n            for (let i = 1; i < count; i++) {\n                // does next candidate point nearer the head or the tail of the axis?\n                if (Math.abs(angleSpan(axis, sheaf[i].angle)) < HalfPi) {\n                    // chain this candidate onto the emerging axis\n                    uSum += sheaf[i].u\n                    vSum += sheaf[i].v\n                    // the first unflipped candidate after one or more flipped ones clocks a new revolution\n                    if (flipped) {\n                        flipped = false\n                        turns++\n                        endTime = sheaf[i].time\n                    }\n                } else { // flip this arrow before chaining it, as it's pointing the \"wrong\" way\n                    flipped = true\n                    uSum -= sheaf[i].u\n                    vSum -= sheaf[i].v\n                }\n                // get the new blended angle\n                axis = Math.atan2(vSum, uSum)\n                rSum += sheaf[i].size\n            }\n\n            // build the result Arrow\n            result.size = rSum / count  // the average radius\n            result.angle = axis\n            result.u = result.size * Math.cos(axis)\n            result.v = result.size * Math.sin(axis)\n\n            // compute the average rotation time (so long as we've made at least one complete revolution)\n            if (endTime > 0) {\n                result.time = (endTime - startTime) / turns\n            }\n        }\n        // hijack the time property to return the estimated period\n        return result\n    }\n\n\n    /** gives the signed difference between angles a & b (allowing for roll-round)\n     * @param a first angle in radians\n     * @param b second angle in radians\n     * @returns the acute (i.e. smaller) difference in angle\n     */\n    function angleSpan(a: number, b: number) {\n        return ((ThreePi + b - a) % TwoPi) - Math.PI\n    }\n\n    // Convert an angle measured in radians to degrees.\n    function asDegrees(angle: number): number {\n        return ((angle * RadianDegrees) + 360) % 360\n    }\n}\n","pxt.json":"{\n    \"name\": \"heading test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"pxt-heading.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1721283117806,"editorVersion":"7.0.13","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let spinRPM = 0\" numlines=\"1\" declaredvars=\"spinRPM\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let result = 0\" numlines=\"1\" declaredvars=\"result\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"enum Task {\" line1=\"    Scan,\" line2=\"    SetNorth,\" line3=\"    Measure\" line4=\"}\" numlines=\"5\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let nextTask: Task = Task.Scan\" numlines=\"1\" declaredvars=\"nextTask\"></mutation><comment pinned=\"false\" h=\"50\" w=\"50\">new mode, so always start with a scan</comment><next><block type=\"basic_show_arrow\"><value name=\"i\"><shadow type=\"device_arrow\"><field name=\"arrow\">ArrowNames.West</field></shadow></value></block></next></block></next></block></next></block></next></block></statement></block><block type=\"device_button_event\" x=\"386\" y=\"20\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"performSetup\" functionid=\"[vA;:54=Q=ye][K9n$dl\"></mutation></block></statement></block><block type=\"device_button_event\" x=\"648\" y=\"20\"><field name=\"NAME\">Button.B</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"measure\" functionid=\"(?z$N_d[_95s,b)]Uce3\"></mutation></block></statement></block><block type=\"function_definition\" x=\"911\" y=\"20\"><mutation name=\"performSetup\" functionid=\"[vA;:54=Q=ye][K9n$dl\"></mutation><field name=\"function_name\">performSetup</field><statement name=\"STACK\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"switch (nextTask) {\" line1=\"        case Task.Scan:\" line2=\"            let scanTime = 6000 // ...to MANUALLY rotate turntable jig twice (SMOOOOTHLY!)\" line3=\"            basic.showString(&quot;S&quot;)\" line4=\"            basic.pause(1000)\" line5=\"            basic.showString(&quot;_&quot;)\" line6=\"            heading.scanClockwise(scanTime)\" line7=\"            basic.showIcon(IconNames.Yes)\" line8=\"            basic.pause(1000)\" line9=\"            basic.clearScreen()\" line10=\"            basic.showArrow(ArrowNames.West)\" line11=\"            nextTask = Task.SetNorth\" line12=\"            break\" line13=\"\" line14=\"        case Task.SetNorth:\" line15=\"            basic.showString(&quot;N&quot;)\" line16=\"            basic.pause(1000)\" line17=\"            basic.clearScreen()\" line18=\"            result = heading.setNorth()\" line19=\"\" line20=\"            if (result &lt; 0) {\" line21=\"                basic.showIcon(IconNames.Skull) // problem with scan data analysis\" line22=\"                basic.pause(1000)\" line23=\"                basic.showNumber(result)\" line24=\"                basic.pause(1000)\" line25=\"                basic.clearScreen()\" line26=\"                basic.showArrow(ArrowNames.West)\" line27=\"                nextTask = Task.Scan // restart with a fresh scan\" line28=\"            } else {\" line29=\"                spinRPM = heading.spinRate() // ...just out of interest\" line30=\"                basic.showNumber(Math.floor(spinRPM))\" line31=\"                basic.pause(1000)\" line32=\"                basic.showIcon(IconNames.Yes)\" line33=\"                basic.pause(500)\" line34=\"                basic.showLeds(`\" line35=\"                    # # . # #\" line36=\"                    # . . . #\" line37=\"                    . . # . .\" line38=\"                    # . . . #\" line39=\"                    # # . # #\" line40=\"                    `)\" line41=\"                basic.pause(500)\" line42=\"                basic.showArrow(ArrowNames.East)\" line43=\"                nextTask = Task.Measure\" line44=\"            }\" line45=\"            break\" line46=\"\" line47=\"        case Task.Measure: // Button A allows new North setting\" line48=\"            basic.showIcon(IconNames.No)\" line49=\"            basic.pause(1000)\" line50=\"            basic.clearScreen()\" line51=\"            basic.showArrow(ArrowNames.West)\" line52=\"            nextTask = Task.SetNorth // reset new North\" line53=\"            break\" line54=\"    }\" numlines=\"55\"></mutation></block></statement></block><block type=\"function_definition\" x=\"1780\" y=\"20\"><mutation name=\"measure\" functionid=\"(?z$N_d[_95s,b)]Uce3\"></mutation><field name=\"function_name\">measure</field><statement name=\"STACK\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"switch (nextTask) {\" line1=\"        // ? sequence error?\" line2=\"        case Task.SetNorth:\" line3=\"        case Task.Scan: // use button A to do a scan first\" line4=\"            for (let i = 0; i &lt; 5; i++) {\" line5=\"                basic.clearScreen()\" line6=\"                basic.pause(100)\" line7=\"                basic.showArrow(ArrowNames.West)\" line8=\"            }\" line9=\"            break\" line10=\"\" line11=\"        case Task.Measure: // OK, take a new heading measurement\" line12=\"            basic.pause(200)\" line13=\"            basic.clearScreen()\" line14=\"            basic.pause(50)\" line15=\"            let compass = heading.degrees()\" line16=\"            basic.showNumber(Math.floor(compass))\" line17=\"            basic.pause(500)\" line18=\"            // now MANUALLY move to next test-angle...\" line19=\"            basic.showLeds(`\" line20=\"                    # # . # #\" line21=\"                    # . . . #\" line22=\"                    . . . . .\" line23=\"                    # . . . #\" line24=\"                    # # . # #\" line25=\"                    `)\" line26=\"            basic.pause(200)\" line27=\"            break\" line28=\"    }\" numlines=\"29\"></mutation></block></statement></block></xml>","main.ts":"","README.md":"","pxt-heading.ts":"\n// TODO? No use is yet made of the accelerometer. Although seemingly helpful to compensate for\n// static tilt, on a moving buggy dynamic sideways accelerations confound the measurement of \"down\",\n// so applying tilt-compensation could actually make compass-heading accuracy worse!\n\n\n\n//% color=#6080e0 weight=40 icon=\"\\uf14e\" block=\"Heading\" \n/**\n * An extension providing a compass-bearing for a buggy located anywhere on the globe \n * (except at the magnetic poles!), with any arbitrary mounting orientation for its microbit.\n * \n * See the README for a detailed description of the approach, methods and algorithms.\n */\nnamespace heading {\n\n    // ENUMERATIONS\n    enum View { // the axis-pairs that span the three possible magnetometer projection planes\n        XY,\n        YZ,\n        ZX\n    }\n\n    // CONSTANTS\n\n    const HalfPi = Math.PI / 2\n    const TwoPi = 2 * Math.PI\n    const ThreePi = 3 * Math.PI\n    const RadianDegrees = 360 / TwoPi\n    const EnoughScanTime = 1500 // minimum acceptable scan-time\n    const EnoughSamples = 70 // fewest acceptable scan samples\n    const TooManySamples = 500 // don't be too greedy with memory!\n    const MarginalField = 10 // minimum acceptable field-strength for magnetometer readings\n    const Circular = 1.03 // maximum eccentricity to consider an Ellipse as \"circular\" (3% gives ~1 degree error)\n    const NearEnough = 0.75 // major-axis candidates must be longer than (longest*NearEnough)\n    // minor-axis candidates must be shorter than (shortest/NearEnough) \n    const Window = 8 // number of magnetometer samples needed to form a good average\n    const SampleGap = 15 // minimum ms to wait between magnetometer readings\n    const AverageGap = 25 // (achieved in practice, due to system interrupts)\n    const Latency = Window * AverageGap // consequent time taken to collect a good moving average from scratch\n\n    // SUPPORTING CLASSES\n\n    // An Arrow is an object holding a directed vector {u,v} in both Cartesian and Polar coordinates. \n    // It also carries a time-field, used to timestamp scanned samples.\n    // An Arrow is used to hold a 2D magnetometer measurement as a re-centred vector.\n\n    class Arrow {\n        u: number; // horizontal component\n        v: number; // vertical component\n        size: number; // polar magnitude of vector\n        angle: number; // polar angle (radians anticlockwise from East)\n        time: number; // for scan samples, timestamp of when this was collected\n\n        constructor(u: number, v: number, t: number) {\n            this.u = u\n            this.v = v\n            this.size = Math.sqrt((u * u) + (v * v))\n            this.angle = 0\n            if (this.size > 0) { // defend against zero-divide\n                this.angle = Math.atan2(v, u)\n            }\n            this.time = t\n        }\n        // when copying...\n        cloneMe(): Arrow {\n            return new Arrow(this.u, this.v, this.time)\n        }\n    }\n\n    // A Smoother object computes a moving average from a sequence of time-stamped values: \n    // in our case, magnetometer readings and their derivatives.\n    // Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n    // The constant {Window} governs the latency of the exponential averaging process.\n    // Smoothers can work with arbitrary-sized vectors of values that share the same timestamp.\n    // history[], previous[], latest[] and result[] arrays will be either 3-D, (for initial [X,Y,Z] scanning)\n    // or 2-D, (for analysing chosen the [uDim,vDim]).\n    class Smoother {\n        dims: number; // dimensionality\n        average: number[] = []; // \n        lastTime: number;\n        lastInputs: number[] = [];\n\n        constructor(first: number[], start: number) {\n            this.dims = first.length\n            this.lastTime = start\n            for (let i = 0; i < this.dims; i++) {\n                this.average.push(first[i])\n                this.lastInputs.push(first[i])\n            }\n        }\n\n        update(values: number[], timeStamp: number): number[] {\n            // work out appropriate blend, based on time-step\n            let timeFraction = (timeStamp - this.lastTime) / Latency\n            let keepOld = Math.exp(-timeFraction)\n            let inherited = (1 - keepOld) / timeFraction\n            // we amplify the most recent sample's contribution to the inherited average\n            let boostLast = (inherited - keepOld)\n            let addNew = (1 - inherited)\n            // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n            // apply blending to all elements of old and new data arrays\n            let result: number[] = []\n            for (let i = 0; i < this.dims; i++) {\n                result.push(keepOld * this.average[i]\n                    + boostLast * this.lastInputs[i]\n                    + addNew * values[i])\n            }\n            // update history for next time around\n            this.lastTime = timeStamp\n            this.average = result\n            this.lastInputs = values\n\n            return result\n        }\n    }\n\n\n    // An Ellipse is an object holding the characteristics of the (typically) elliptical\n    // view formed when projecting the scan Spin-Circle onto a 2-axis View-plane.\n    class Ellipse {\n        plane: string; // View name (just for debug)\n        uDim: number; // horizontal axis of this View\n        vDim: number; // vertical axis of this View\n        uOff: number; // horizontal offset needed to re-centre this Ellipse along the U-axis\n        vOff: number; // vertical offset needed to re-centre this Ellipse along the V-axis\n\n        // calibration characteristics\n        majorAngle: number; // direction of the Ellipse major axis \n        period: number; // scan-rotation time as viewed in this plane\n        eccentricity: number; // ratio of major-axis to minor-axis magnitudes for this Ellipse\n        isCircular: boolean; // flag saying this \"Ellipse\" View is almost circular, simplifying future handling\n        rotationSense: number; // rotation reversal sign = +/-1, reflecting this Ellipse's view of the clockwise scan\n\n        constructor(plane: string, uDim: number, vDim: number, uOff: number, vOff: number) {\n            this.plane = plane // (as a DEBUG aid)\n            this.uDim = uDim\n            this.vDim = vDim\n            this.uOff = uOff\n            this.vOff = vOff\n            this.isCircular = false // until proved otherwise!\n            this.period = -1\n        }\n\n        // This method analyses a 2-D subset of the scanData for a projected View of the Spin-Circle,\n        // creating an Arrow indicating the major-axis direction of the elliptical View.\n        // It performs several tasks:\n        // 1) By comparing the longest and shortest radii, this method works out the eccentricity of \n        //    the Ellipse, as seen from this View. Also notes whether being viewed \"from below\".\n        // 2) It collects possible candidates for the Ellipse major and minor axes by looking for local \n        //    radius peaks and troughs; candidate values are pushed onto two lists of Arrows:\n        //    this.majors[] and this.minors[]\n        // 3) These lists are then carefully assessed to evolve a consensus for the two axes. \n        //    For \"pointy\" Ellipses we get a single candidate each time we pass either end of the axis.\n        //    For \"rounder\" Ellipses each transit may deliver multiple candidates. If a candidate points \n        //    closer to the head of the ongoing mean, it is added in; if it points closer to the tail, \n        //    then it's inverse is added in (as it must \"belong\" to the other end of the axis).\n        // 4) As we do this, we work out the rotation period by clocking each time we flip ends of the axis.\n        // 5) All this analysis results in a single Arrow for each axis which can be averaged (after turning\n        //    the minor axis through a right-angle)\n\n\n        analyseView() {\n            let majors: Arrow[] = [] // candidate directions for major axis of Ellipse\n            let minors: Arrow[] = [] // candidate directions for minor axis of Ellipse\n            let major: Arrow = new Arrow(0, 0, 0)\n            let minor: Arrow = new Arrow(0, 0, 0)\n            let longest = 0\n            let shortest = 99999\n            let spin = 0\n            let sizeWas: number\n            let angleWas: number\n            let step: number = 99999 // marker for \"first time round\"\n            let stepWas: number\n            // extract coordinates of the first point lying in this.plane\n            let point = [scanData[0][this.uDim], scanData[0][this.vDim]]\n            // set up a 2D Smoother for points on this Ellipse\n            let curve = new Smoother(point, scanTimes[0])\n            // compare first one with remaining samples\n            let trial = new Arrow(point[0], point[1], scanTimes[0])\n            for (let i = 1; i < scanTimes.length; i++) {\n                sizeWas = trial.size\n                angleWas = trial.angle\n                // blend the next point into the moving average\n                point = curve.update([scanData[i][this.uDim], scanData[i][this.vDim]], scanTimes[i])\n                trial = new Arrow(point[0], point[1], scanTimes[i])\n\n                // accumulate gradual rotation of the projected field-vector...\n                let delta = trial.angle - angleWas\n                spin += delta\n                // fix roll-rounds in either direction\n                if (delta > HalfPi) spin -= TwoPi // apparent big positive jump is due to underflow\n                if (delta < -HalfPi) spin += TwoPi // apparent big negative jump is due to overflow\n\n                // now collect candidates for axes  \n                stepWas = step\n                step = trial.size - sizeWas // is radius growing or shrinking (or the same!)?\n                if (stepWas == 99999) stepWas = step // (ensure that the first two steps will always match)\n                if (step == 0) step = stepWas // ignore any (rare!) static sequence by propagating last step\n\n                // look for peaks, where we switch from growing to shrinking\n                if ((stepWas > 0) && (step < 0)) {\n                    longest = Math.max(longest, trial.size)\n                    majors.push(trial.cloneMe()) // copy the major axis we are passing\n                }\n\n                // look for troughs, where we switch from shrinking to growing\n                if ((stepWas < 0) && (step > 0)) {\n                    shortest = Math.min(shortest, trial.size)\n                    minors.push(trial.cloneMe()) // copy the minor axis we are passing\n                }\n\n            }\n            // During a clockwise scan, the projection-angle of the field-vector as viewed from above \n            // will appear to rotate anticlockwise (increasing radians) from the perspective of the Buggy. \n            // If we find it rotates clockwise (decreasing radians) then this projection-plane must be \n            // viewing the field-vector from below.\n            this.rotationSense = spin / Math.abs(spin) // == -1 if viewing from below\n\n            /* PERIODICITY FROM SPIN?\n             Why not simply use the accumulated spin-angle and time-span to calculate the rotation-period?\n             --Because the arbitrary start and end angles may be subject to fore-shortening, and hence\n             quite inaccurate! The only dependable angles occur just as we pass over the axes (see below).\n            */\n\n\n            /* We are trying to find a good approximation to the tilt of the Ellipse's major-axis.  \n            We could simply nominate the longest candidate detected, but instead we will average them.\n\n            If the Ellipse is quite eccentric, it will yield neatly alternating candidates with \n            \"opposite\" angles.passing the major-axis twice per Spin-circle revolution \n\n            With a more-nearly circular Ellipse, noisy readings can yield alternating clusters of local maxima \n            gathered near each end of the axis.\n\n            An almost circular Ellipse has no meaningful axis and generally yields multiple spurious candidates. \n            */\n\n            // purge any local maximum whose vector length is too short --it's nowhere near the major-axis!\n            let long = longest * NearEnough\n            for (let i = 0; i < majors.length; i++) {\n                if (majors[i].size < long) {\n                    majors.splice(i, 1)  // disqualified!\n                    i-- // (all subsequent candidates now shuffle up by one place!)\n                }\n            }\n\n            // similarly purge all errant local minima that are too big\n            let short = shortest / NearEnough\n            for (let i = 0; i < minors.length; i++) {\n                if (minors[i].size > short) {\n                    minors.splice(i, 1)\n                    i--\n                }\n            }\n\n\n            // form consensus averages of the two ends of the two axes\n            major = computeAxis(majors)\n            minor = computeAxis(minors)\n\n            // average the axis angles carefully: minor axis is always orthgonal, but phase may lead or follow!\n            let minorTurned = minor.angle + HalfPi // assume it leads by 90 degrees\n            if (angleSpan(major.angle, minor.angle) > 0) {\n                minorTurned += Math.PI // no: it follows, so add another 180 degrees\n            }\n            // use the average of the two angles\n            this.majorAngle = ((major.angle + minorTurned) / 2) % TwoPi\n            // The ratio of the axis lengths gives the eccentricity of this Ellipse\n            this.eccentricity = major.size / minor.size\n            // average the periodicities detected \n            this.period = (major.time + minor.time) / 2\n            // Readings on a near-circular Ellipse won't ever be fore-shortened, so we can skip correction!\n            this.isCircular = (this.eccentricity < Circular)\n        }\n    }\n\n\n\n    // GLOBALS\n\n    let scanTimes: number[] = [] // sequence of time-stamps for scanned readings \n    let scanData: number[][] = [] // scanned sequence of [X,Y,Z] magnetometer readings\n    let scanTime: number = 0 // duration of scan in ms\n    let views: Ellipse[] = [] // the three possible elliptical views of the Spin-Circle\n    let bestView = -1\n    let uDim = -1 // the \"horizontal\" axis (called U) for the best View\n    let vDim = -1 // the \"vertical\" axis (called V) for the best View\n    let north = 0 // reading registered as \"North\"\n    let strength = 0 // the average magnetic field-strength observed by the magnetometer\n    let period = -1 // overall assessment of average rotation time\n\n    // correction parameters adopted from bestView Ellipse for future readings\n    let rotationSense = 1 // set to -1 if orientation means field-vector projection is \"from below\"\n    let isCircular: boolean // if bestView Ellipse is circular, no correction is needed\n    let uOff: number // horizontal origin offset\n    let vOff: number // vertical origin offset\n    let theta: number  // major-axis tilt angle (in radians anticlockwise from the U-axis)\n    let cosTheta: number; // saved for efficiency\n    let sinTheta: number; //      ditto\n    let scale: number // stretch-factor for correcting foreshortened readings (= eccentricity)\n\n    // EXPORTED USER INTERFACES   \n\n    /** \n     * Assuming the buggy is currently spinning clockwise on the spot, capture a \n     * time-stamped sequence of magnetometer readings from which to set up the compass.\n     *\n     * @param ms scanning-time in millisecs (long enough for more than one full rotation)    \n     */\n\n    //% block=\"scan clockwise for (ms) $ms\" \n    //% inlineInputMode=inline \n    //% ms.shadow=\"timePicker\" \n    //% ms.defl=0 \n    //% weight=90 \n\n    export function scanClockwise(ms: number) {\n        // Sample magnetometer readings periodically over the specified duration (generally a couple\n        // of seconds), and append a new [X,Y,Z] triple to the scanData[] array.\n        // A timestamp for each sample is also recorded in the scanTimes[] array.\n\n        // NOTE: To smooth out jitter, each reading is always a moving average of several consecutive readings.\n        // Because sample-times may be irregular (due to scheduled interrupts), a Smoother is used to provide\n        // a timing-aware exponential moving-average. The sample-grouping and spacing are controlled \n        // respectively by the constants Window and SampleGap, which together determine the Latency.\n\n        scanTimes = []\n        scanData = []\n        let index = 0\n\n        let timeWas: number\n        let timeNow: number\n        let fresh: number[] = []\n        let updated: number[] = []\n\n        basic.pause(200) // wait for motors to stabilise (after initial kick)\n        // get initial reading\n        let timeStamp = input.runningTime()\n        fresh = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n        // use a Smoother to maintain a rolling average\n        let scan = new Smoother(fresh, timeStamp)\n\n        // after an initial settling period, continue cranking out updated moving averages \n        let startTime = timeStamp + Latency\n        let stopTime = timeStamp + ms\n\n        // until we run out of time (or space!)\n        while ((timeStamp < stopTime)\n            && (scanTimes.length < TooManySamples)) {\n            // After processing, sleep until it's time for next sample.\n            // NOTE: here is where various system subprograms will get scheduled.\n            // If they need more time than we've offered, out next sample will get delayed!\n            // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n            timeWas = timeStamp // remember time of latest sample\n            timeNow = input.runningTime()\n            basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n            timeStamp = input.runningTime() // take a fresh set of readings\n\n            fresh = [\n                input.magneticForce(Dimension.X),\n                input.magneticForce(Dimension.Y),\n                input.magneticForce(Dimension.Z)]\n            updated = scan.update(fresh, timeStamp)\n\n            // only start recording once the moving average has stabilised\n            if (timeStamp > startTime) {\n                // store the triple of averaged [X,Y,Z] values (as a deep copy!)\n                scanData.push([updated[0], updated[1], updated[2]])\n                scanTimes.push(timeStamp)  // timestamp it\n                index++\n            }\n        }\n    }\n\n    /**\n     * Analyse the scanned data to prepare for reading compass-bearings.\n     * Then read the magnetometer and register the buggy's current direction as \"North\",\n     * (i.e. the direction that will in future return zero as its heading).\n     * \n     * The actual direction of the buggy when this function is called is arbitrary:\n     * it could be Magnetic North; or True North (compensating for local declination); \n     * or any convenient direction from which to measure subsequent heading angles.\n     * \n     * @return zero if successful, or a negative error code:\n     *\n     *      -1 : NOT ENOUGH SCAN DATA\n\n     *      -2 : FIELD STRENGTH TOO WEAK\n     *\n     *      -3 : NOT ENOUGH SCAN ROTATION\n     *\n     */\n    //% block=\"set North\" \n    //% inlineInputMode=inline \n    //% weight=80 \n    export function setNorth(): number {\n        // reset global defaults\n        bestView = -1\n        strength = -1\n        period = -1\n\n        // First analyse the scan-data to decide how best to use the magnetometer readings.\n        // we'll typically need about a couple of second's worth of scanned readings...\n        let nSamples = scanTimes.length\n        scanTime = scanTimes[nSamples - 1] - scanTimes[0]\n\n        if ((nSamples < EnoughSamples) || (scanTime < EnoughScanTime)) {\n            return -1 // \"NOT ENOUGH SCAN DATA\"\n        }\n        // Each dimension should track a sinusoidal wave of values (generally not centred on zero).\n        // The first pass finds the ranges for each axis \n        let xlo = 9999999\n        let ylo = 9999999\n        let zlo = 9999999\n        let xhi = -9999999\n        let yhi = -9999999\n        let zhi = -9999999\n        for (let i = 0; i < nSamples; i++) {\n            xhi = Math.max(xhi, scanData[i][Dimension.X])\n            yhi = Math.max(yhi, scanData[i][Dimension.Y])\n            zhi = Math.max(zhi, scanData[i][Dimension.Z])\n            xlo = Math.min(xlo, scanData[i][Dimension.X])\n            ylo = Math.min(ylo, scanData[i][Dimension.Y])\n            zlo = Math.min(zlo, scanData[i][Dimension.Z])\n        }\n\n        // get RMS field-strength\n        let xField = (xhi - xlo) / 2\n        let yField = (yhi - ylo) / 2\n        let zField = (zhi - zlo) / 2\n        strength = Math.sqrt((xField * xField) + (yField * yField) + (zField * zField))\n\n        // Bail out early if the scan didn't properly detect the Earth's magnetic field,\n        // (perhaps due to magnetic shielding)\n        if (strength < MarginalField) {\n            return -2 // \"FIELD STRENGTH TOO WEAK\"\n        }\n        // The means of the extremes give an approximation to the central offsets.\n        let xOff = (xhi + xlo) / 2\n        let yOff = (yhi + ylo) / 2\n        let zOff = (zhi + zlo) / 2\n\n        // re-centre all of the scanData samples, so eliminating \"hard-iron\" magnetic effects\n        for (let i = 0; i < nSamples; i++) {\n            scanData[i][Dimension.X] -= xOff\n            scanData[i][Dimension.Y] -= yOff\n            scanData[i][Dimension.Z] -= zOff\n        }\n\n        // create three Ellipse instances for analysing each possible view in turn\n        views.push(new Ellipse(\"XY\", Dimension.X, Dimension.Y, xOff, yOff))\n        views.push(new Ellipse(\"YZ\", Dimension.Y, Dimension.Z, yOff, zOff))\n        views.push(new Ellipse(\"ZX\", Dimension.Z, Dimension.X, zOff, xOff))\n\n        // For each View, perform the analysis of eccentricity and Ellipse tilt-angle\n        views[View.XY].analyseView()\n        views[View.YZ].analyseView()\n        views[View.ZX].analyseView()\n\n        // check that at least one View saw at least one complete rotation (with a measurable period)...\n        if ((views[View.XY].period == -1)\n            && (views[View.YZ].period == -1)\n            && (views[View.ZX].period == -1)) {\n            return -3 // \"NOT ENOUGH SCAN ROTATION\"\n        }\n\n        // Choose the \"roundest\" Ellipse  --the one with lowest eccentricity.\n        bestView = View.XY\n        if (views[View.YZ].eccentricity < views[bestView].eccentricity) bestView = View.YZ\n        if (views[View.ZX].eccentricity < views[bestView].eccentricity) bestView = View.ZX\n\n        // periodicity is unreliable in a near-circular View: average just the other two Views' measurements\n        period = (views[0].period + views[1].period + views[2].period - views[bestView].period) / 2\n\n        // For efficiency, extract various characteristics from our adopted \"bestView\" Ellipse\n        uDim = views[bestView].uDim\n        vDim = views[bestView].vDim\n        uOff = views[bestView].uOff\n        vOff = views[bestView].vOff\n        scale = views[bestView].eccentricity // scaling needed to balance axes\n        theta = views[bestView].majorAngle // the rotation (in radians) of the major-axis from the U-axis\n        cosTheta = Math.cos(theta)\n        sinTheta = Math.sin(theta)\n        isCircular = views[bestView].isCircular\n        rotationSense = views[bestView].rotationSense\n\n        // Having successfully set up the projection parameters for the bestView, get a\n        // stable fix on the current heading, which we will then designate as \"North\".\n        // (This is the global fixed bias to be subtracted from all future readings)\n        north = takeSingleReading()\n\n        // we've now finished with the scanning data and Ellipse objects, so release their memory\n        scanTimes = []\n        scanData = []\n        views = []\n\n        // SUCCESS!\n        return 0\n    }\n\n\n    /**\n     * Read the magnetometer\n     * \n     * @return the current heading of the buggy\n     * \n     * (in degrees clockwise, relative to \"North\")\n     */\n    //% block=\"degrees\" \n    //% inlineInputMode=inline \n    //% weight=70\n    export function degrees(): number {\n        // Depending on mounting orientation, the bestView might possibly be seeing the Spin-Circle from\n        // \"underneath\", with the field-vector appearing to move clockwise  --effectively experiencing an\n        // anti-clockwise scan. In this case the rotationSense will be negative.\n        return asDegrees((takeSingleReading() - north) * rotationSense)\n        // NOTE: that there is a double reversal going on here:\n        // Viewed from above, the Field-vector reading in radians INCREASES (anticlockwise) w.r.t \"North\"\n        // as the buggy's compass-heading INCREASES (clockwise).\n        // So after a right-turn while facing North, the reading is HalfPi bigger than the North reading.\n        // After subtracting North (cyclically), that converts asDegrees() to +90 \n        // From below (when rotationSense = -1), the same right-turn would DECREASE the reading by HalfPi\n        // necessitating a third reversal (after first subtracting North) !\n    }\n\n    /**\n     * The average rotation time of the most recent scan \n     * @return rotation time, or error-value:\n     * \n     *      -4 : SUCCESSFUL SCAN IS NEEDED FIRST\n     */\n    //% block=\"spin time (ms)\" \n    //% inlineInputMode=inline \n    //% weight=60 \n    export function spinTime(): number {\n        if (period == -1) {\n            return -4 // ERROR: SUCCESSFUL SCAN IS NEEDED FIRST\n        } else {\n            return period\n        }\n    }\n\n    /**\n     * The average rotation rate of the most recent scan \n     * \n     * @return revs-per-minute, or error value:\n     * \n     *      -4 : SUCCESSFUL SCAN IS NEEDED FIRST\n     */\n    //% block=\"spin rate (RPM)\" \n    //% inlineInputMode=inline \n    //% weight=50 \n    export function spinRate(): number {\n        if (period == -1) {\n            return -4 // ERROR: SUCCESSFUL SCAN IS NEEDED FIRST\n        } else {\n            return 60000 / period\n        }\n    }\n\n    /**\n     * While scanning, wheels are rotated in opposite directions, giving a spin-rate for the \n     * selected power setting. Based on the axle-length and latest spin-rate, this function \n     * estimates the forward speed to be expected when using that power setting.\n     * (NOTE that tyre-friction or skidding when turning may make this a fairly inaccurate estimate!)\n     * \n     * @param axleLength : distance betweeen mid-lines of tyres (in mm)\n     * \n     * @return speed in mm-per-second, or error value:\n     * \n     *      -4 : SUCCESSFUL SCAN IS NEEDED FIRST\n     */\n    //% block=\"equivalent speed (mm/s), axle length (mm) = $axleLength\" \n    //% inlineInputMode=inline \n    //% weight=50 \n    export function equivalentSpeed(axleLength: number): number {\n        if (period < 0) {\n            return -4 // ERROR: SUCCESSFUL SCAN IS NEEDED FIRST\n        } else {\n            // compute tangential speed of wheel-centre in mm/s:\n            // it takes [period] ms to cover [2pi * axleLength/2] mm\n            return (Math.PI * axleLength * 1000 / period)\n        }\n    }\n\n\n    // UTILITY FUNCTIONS\n\n    /** Take the sum of several new readings to get a stable fix on the current heading.\n     *  @return the projected angle of the magnetic field-vector (in radians anticlockwise\n     * from the horizontal U-axis)\n     */\n\n    function takeSingleReading(): number {\n        let uRaw = 0\n        let vRaw = 0\n        let u = 0\n        let v = 0\n        let uNew = 0\n        let vNew = 0\n        let uFix = 0\n        let vFix = 0\n        let reading = 0\n        // get a new sample as the average of {Window} consecutive 2D readings, {SampleGap} apart\n        for (let i = 0; i < Window; i++) {\n            basic.pause(SampleGap)\n            uRaw += input.magneticForce(uDim)\n            vRaw += input.magneticForce(vDim)\n        }\n        uRaw /= Window\n        vRaw /= Window\n\n        // re-centre this latest point w.r.t our Ellipse origin\n        u = uRaw - uOff\n        v = vRaw - vOff\n\n        if (isCircular) {\n            reading = Math.atan2(v, u)\n        } else {\n            // Unless this Ellipse.isCircular, any {u,v} reading will be foreshortened in this View, and\n            // must be stretched along the Ellipse minor-axis to place it correctly onto the Spin-Circle.\n\n            // First rotate CLOCKWISE by theta (so aligning the Ellipse minor-axis angle with the V-axis)\n            uNew = u * cosTheta + v * sinTheta\n            vNew = v * cosTheta - u * sinTheta\n            // Now scale up along V, re-balancing the axes to make the Ellipse circular\n            uFix = uNew\n            vFix = vNew * scale\n            // get the adjusted angle for this corrected {u,v}\n            reading = Math.atan2(vFix, uFix)\n            // finally, undo the rotation by theta\n            reading += theta\n        }\n        return reading\n    }\n\n    /* Use vector addition to average a sequence of candidate axis Arrows (concievably empty!)\n    // The ones pointing away from the first one are assumed to belong to the other end\n    // of the axis, so will get reversed.\n    // The returned Arrow shows the average axis length and angle.\n    // Assuming candidates represent more than one revolution, the periodocity is also calculated.\n    */\n    function computeAxis(sheaf: Arrow[]): Arrow {\n        let result = new Arrow(0, 0, 0)\n        let turns = 0\n        let startTime = 0\n        let endTime = 0\n        let period = -1\n        let flipped = false\n        let uSum = 0\n        let vSum = 0\n        let rSum = 0\n        let count = sheaf.length\n        if (count > 0) {\n            // initialise axis as first (or only?) candidate\n            uSum = sheaf[0].u\n            vSum = sheaf[0].v\n            rSum = sheaf[0].size\n            let axis = sheaf[0].angle\n            startTime = sheaf[0].time\n            flipped = false\n            for (let i = 1; i < count; i++) {\n                // does next candidate point nearer the head or the tail of the axis?\n                if (Math.abs(angleSpan(axis, sheaf[i].angle)) < HalfPi) {\n                    // chain this candidate onto the emerging axis\n                    uSum += sheaf[i].u\n                    vSum += sheaf[i].v\n                    // the first unflipped candidate after one or more flipped ones clocks a new revolution\n                    if (flipped) {\n                        flipped = false\n                        turns++\n                        endTime = sheaf[i].time\n                    }\n                } else { // flip this arrow before chaining it, as it's pointing the \"wrong\" way\n                    flipped = true\n                    uSum -= sheaf[i].u\n                    vSum -= sheaf[i].v\n                }\n                // get the new blended angle\n                axis = Math.atan2(vSum, uSum)\n                rSum += sheaf[i].size\n            }\n\n            // build the result Arrow\n            result.size = rSum / count  // the average radius\n            result.angle = axis\n            result.u = result.size * Math.cos(axis)\n            result.v = result.size * Math.sin(axis)\n\n            // compute the average rotation time (so long as we've made at least one complete revolution)\n            if (endTime > 0) {\n                result.time = (endTime - startTime) / turns\n            }\n        }\n        // hijack the time property to return the estimated period\n        return result\n    }\n\n\n    /** gives the signed difference between angles a & b (allowing for roll-round)\n     * @param a first angle in radians\n     * @param b second angle in radians\n     * @returns the acute (i.e. smaller) difference in angle\n     */\n    function angleSpan(a: number, b: number) {\n        return ((ThreePi + b - a) % TwoPi) - Math.PI\n    }\n\n    // Convert an angle measured in radians to degrees.\n    function asDegrees(angle: number): number {\n        return ((angle * RadianDegrees) + 360) % 360\n    }\n}\n","pxt.json":"{\n    \"name\": \"heading test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"pxt-heading.ts\"\n    ],\n    \"preferredEditor\": \"blocksprj\"\n}\n"}},{"timestamp":1721491854776,"editorVersion":"7.0.13","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let spinRPM = 0\" numlines=\"1\" declaredvars=\"spinRPM\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let result = 0\" numlines=\"1\" declaredvars=\"result\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"enum Task {\" line1=\"    Scan,\" line2=\"    SetNorth,\" line3=\"    Measure\" line4=\"}\" numlines=\"5\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let nextTask: Task = Task.Scan\" numlines=\"1\" declaredvars=\"nextTask\"></mutation><comment pinned=\"false\" h=\"50\" w=\"50\">new mode, so always start with a scan</comment><next><block type=\"basic_show_arrow\"><value name=\"i\"><shadow type=\"device_arrow\"><field name=\"arrow\">ArrowNames.West</field></shadow></value></block></next></block></next></block></next></block></next></block></statement></block><block type=\"device_button_event\" x=\"366\" y=\"0\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"performSetup\" functionid=\"[vA;:54=Q=ye][K9n$dl\"></mutation></block></statement></block><block type=\"device_button_event\" x=\"628\" y=\"0\"><field name=\"NAME\">Button.B</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"measure\" functionid=\"(?z$N_d[_95s,b)]Uce3\"></mutation></block></statement></block><block type=\"function_definition\" x=\"891\" y=\"0\"><mutation name=\"performSetup\" functionid=\"[vA;:54=Q=ye][K9n$dl\"></mutation><field name=\"function_name\">performSetup</field><statement name=\"STACK\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"switch (nextTask) {\" line1=\"        case Task.Scan:\" line2=\"            let scanTime = 6000 // ...to MANUALLY rotate turntable jig twice (SMOOOOTHLY!)\" line3=\"            basic.showString(&quot;S&quot;)\" line4=\"            basic.pause(1000)\" line5=\"            basic.showString(&quot;_&quot;)\" line6=\"            heading.scanClockwise(scanTime)\" line7=\"            basic.showIcon(IconNames.Yes)\" line8=\"            basic.pause(1000)\" line9=\"            basic.clearScreen()\" line10=\"            basic.showArrow(ArrowNames.West)\" line11=\"            nextTask = Task.SetNorth\" line12=\"            break\" line13=\"\" line14=\"        case Task.SetNorth:\" line15=\"            basic.showString(&quot;N&quot;)\" line16=\"            basic.pause(1000)\" line17=\"            basic.clearScreen()\" line18=\"            result = heading.setNorth()\" line19=\"\" line20=\"            if (result &lt; 0) {\" line21=\"                basic.showIcon(IconNames.Skull) // problem with scan data analysis\" line22=\"                basic.pause(1000)\" line23=\"                basic.showNumber(result)\" line24=\"                basic.pause(1000)\" line25=\"                basic.clearScreen()\" line26=\"                basic.showArrow(ArrowNames.West)\" line27=\"                nextTask = Task.Scan // restart with a fresh scan\" line28=\"            } else {\" line29=\"                spinRPM = heading.spinRate() // ...just out of interest\" line30=\"                basic.showNumber(Math.floor(spinRPM))\" line31=\"                basic.pause(1000)\" line32=\"                basic.showIcon(IconNames.Yes)\" line33=\"                basic.pause(500)\" line34=\"                basic.showLeds(`\" line35=\"                    # # . # #\" line36=\"                    # . . . #\" line37=\"                    . . # . .\" line38=\"                    # . . . #\" line39=\"                    # # . # #\" line40=\"                    `)\" line41=\"                basic.pause(500)\" line42=\"                basic.showArrow(ArrowNames.East)\" line43=\"                nextTask = Task.Measure\" line44=\"            }\" line45=\"            break\" line46=\"\" line47=\"        case Task.Measure: // Button A allows new North setting\" line48=\"            basic.showIcon(IconNames.No)\" line49=\"            basic.pause(1000)\" line50=\"            basic.clearScreen()\" line51=\"            basic.showArrow(ArrowNames.West)\" line52=\"            nextTask = Task.SetNorth // reset new North\" line53=\"            break\" line54=\"    }\" numlines=\"55\"></mutation></block></statement></block><block type=\"function_definition\" x=\"1760\" y=\"0\"><mutation name=\"measure\" functionid=\"(?z$N_d[_95s,b)]Uce3\"></mutation><field name=\"function_name\">measure</field><statement name=\"STACK\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"switch (nextTask) {\" line1=\"        // ? sequence error?\" line2=\"        case Task.SetNorth:\" line3=\"        case Task.Scan: // use button A to do a scan first\" line4=\"            for (let i = 0; i &lt; 5; i++) {\" line5=\"                basic.clearScreen()\" line6=\"                basic.pause(100)\" line7=\"                basic.showArrow(ArrowNames.West)\" line8=\"            }\" line9=\"            break\" line10=\"\" line11=\"        case Task.Measure: // OK, take a new heading measurement\" line12=\"            basic.pause(200)\" line13=\"            basic.clearScreen()\" line14=\"            basic.pause(50)\" line15=\"            let compass = heading.degrees()\" line16=\"            basic.showNumber(Math.floor(compass))\" line17=\"            basic.pause(500)\" line18=\"            // now MANUALLY move to next test-angle...\" line19=\"            basic.showLeds(`\" line20=\"                    # # . # #\" line21=\"                    # . . . #\" line22=\"                    . . . . .\" line23=\"                    # . . . #\" line24=\"                    # # . # #\" line25=\"                    `)\" line26=\"            basic.pause(200)\" line27=\"            break\" line28=\"    }\" numlines=\"29\"></mutation></block></statement></block></xml>","main.ts":"function performSetup () {\n    switch (nextTask) {\n        case Task.Scan:\n            let scanTime = 6000 // ...to MANUALLY rotate turntable jig twice (SMOOOOTHLY!)\n            basic.showString(\"S\")\n            basic.pause(1000)\n            basic.showString(\"_\")\n            heading.scanClockwise(scanTime)\n            basic.showIcon(IconNames.Yes)\n            basic.pause(1000)\n            basic.clearScreen()\n            basic.showArrow(ArrowNames.West)\n            nextTask = Task.SetNorth\n            break\n\n        case Task.SetNorth:\n            basic.showString(\"N\")\n            basic.pause(1000)\n            basic.clearScreen()\n            result = heading.setNorth()\n\n            if (result < 0) {\n                basic.showIcon(IconNames.Skull) // problem with scan data analysis\n                basic.pause(1000)\n                basic.showNumber(result)\n                basic.pause(1000)\n                basic.clearScreen()\n                basic.showArrow(ArrowNames.West)\n                nextTask = Task.Scan // restart with a fresh scan\n            } else {\n                spinRPM = heading.spinRate() // ...just out of interest\n                basic.showNumber(Math.floor(spinRPM))\n                basic.pause(1000)\n                basic.showIcon(IconNames.Yes)\n                basic.pause(500)\n                basic.showLeds(`\n                    # # . # #\n                    # . . . #\n                    . . # . .\n                    # . . . #\n                    # # . # #\n                    `)\n                basic.pause(500)\n                basic.showArrow(ArrowNames.East)\n                nextTask = Task.Measure\n            }\n            break\n\n        case Task.Measure: // Button A allows new North setting\n            basic.showIcon(IconNames.No)\n            basic.pause(1000)\n            basic.clearScreen()\n            basic.showArrow(ArrowNames.West)\n            nextTask = Task.SetNorth // reset new North\n            break\n    }\n}\ninput.onButtonPressed(Button.A, function () {\n    performSetup()\n})\ninput.onButtonPressed(Button.B, function () {\n    measure()\n})\nfunction measure () {\n    switch (nextTask) {\n        // ? sequence error?\n        case Task.SetNorth:\n        case Task.Scan: // use button A to do a scan first\n            for (let i = 0; i < 5; i++) {\n                basic.clearScreen()\n                basic.pause(100)\n                basic.showArrow(ArrowNames.West)\n            }\n            break\n\n        case Task.Measure: // OK, take a new heading measurement\n            basic.pause(200)\n            basic.clearScreen()\n            basic.pause(50)\n            let compass = heading.degrees()\n            basic.showNumber(Math.floor(compass))\n            basic.pause(500)\n            // now MANUALLY move to next test-angle...\n            basic.showLeds(`\n                    # # . # #\n                    # . . . #\n                    . . . . .\n                    # . . . #\n                    # # . # #\n                    `)\n            basic.pause(200)\n            break\n    }\n}\nlet spinRPM = 0\nlet result = 0\nenum Task {\n    Scan,\n    SetNorth,\n    Measure\n}\n// new mode, so always start with a scan\nlet nextTask: Task = Task.Scan\nbasic.showArrow(ArrowNames.West)\n","README.md":"","pxt-heading.ts":"\n// TODO? No use is yet made of the accelerometer. Although seemingly helpful to compensate for\n// static tilt, on a moving buggy dynamic sideways accelerations confound the measurement of \"down\",\n// so applying tilt-compensation could actually make compass-heading accuracy worse!\n\n\n\n//% color=#6080e0 weight=40 icon=\"\\uf14e\" block=\"Heading\" \n/**\n * An extension providing a compass-bearing for a buggy located anywhere on the globe \n * (except at the magnetic poles!), with any arbitrary mounting orientation for its microbit.\n * \n * See the README for a detailed description of the approach, methods and algorithms.\n */\nnamespace heading {\n\n    // ENUMERATIONS\n    enum View { // the axis-pairs that span the three possible magnetometer projection planes\n        XY,\n        YZ,\n        ZX\n    }\n\n    // CONSTANTS\n\n    const HalfPi = Math.PI / 2\n    const TwoPi = 2 * Math.PI\n    const ThreePi = 3 * Math.PI\n    const RadianDegrees = 360 / TwoPi\n    const EnoughScanTime = 1500 // minimum acceptable scan-time\n    const EnoughSamples = 70 // fewest acceptable scan samples\n    const TooManySamples = 500 // don't be too greedy with memory!\n    const MarginalField = 10 // minimum acceptable field-strength for magnetometer readings\n    const Circular = 1.03 // maximum eccentricity to consider an Ellipse as \"circular\" (3% gives ~1 degree error)\n    const NearEnough = 0.75 // major-axis candidates must be longer than (longest*NearEnough)\n    // minor-axis candidates must be shorter than (shortest/NearEnough) \n    const Window = 8 // number of magnetometer samples needed to form a good average\n    const SampleGap = 15 // minimum ms to wait between magnetometer readings\n    const AverageGap = 25 // (achieved in practice, due to system interrupts)\n    const Latency = Window * AverageGap // consequent time taken to collect a good moving average from scratch\n\n    // SUPPORTING CLASSES\n\n    // An Arrow is an object holding a directed vector {u,v} in both Cartesian and Polar coordinates. \n    // It also carries a time-field, used to timestamp scanned samples.\n    // An Arrow is used to hold a 2D magnetometer measurement as a re-centred vector.\n\n    class Arrow {\n        u: number; // horizontal component\n        v: number; // vertical component\n        size: number; // polar magnitude of vector\n        angle: number; // polar angle (radians anticlockwise from East)\n        time: number; // for scan samples, timestamp of when this was collected\n\n        constructor(u: number, v: number, t: number) {\n            this.u = u\n            this.v = v\n            this.size = Math.sqrt((u * u) + (v * v))\n            this.angle = 0\n            if (this.size > 0) { // defend against zero-divide\n                this.angle = Math.atan2(v, u)\n            }\n            this.time = t\n        }\n        // when copying...\n        cloneMe(): Arrow {\n            return new Arrow(this.u, this.v, this.time)\n        }\n    }\n\n    // A Smoother object computes a moving average from a sequence of time-stamped values: \n    // in our case, magnetometer readings and their derivatives.\n    // Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n    // The constant {Window} governs the latency of the exponential averaging process.\n    // Smoothers can work with arbitrary-sized vectors of values that share the same timestamp.\n    // history[], previous[], latest[] and result[] arrays will be either 3-D, (for initial [X,Y,Z] scanning)\n    // or 2-D, (for analysing chosen the [uDim,vDim]).\n    class Smoother {\n        dims: number; // dimensionality\n        average: number[] = []; // \n        lastTime: number;\n        lastInputs: number[] = [];\n\n        constructor(first: number[], start: number) {\n            this.dims = first.length\n            this.lastTime = start\n            for (let i = 0; i < this.dims; i++) {\n                this.average.push(first[i])\n                this.lastInputs.push(first[i])\n            }\n        }\n\n        update(values: number[], timeStamp: number): number[] {\n            // work out appropriate blend, based on time-step\n            let timeFraction = (timeStamp - this.lastTime) / Latency\n            let keepOld = Math.exp(-timeFraction)\n            let inherited = (1 - keepOld) / timeFraction\n            // we amplify the most recent sample's contribution to the inherited average\n            let boostLast = (inherited - keepOld)\n            let addNew = (1 - inherited)\n            // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n            // apply blending to all elements of old and new data arrays\n            let result: number[] = []\n            for (let i = 0; i < this.dims; i++) {\n                result.push(keepOld * this.average[i]\n                    + boostLast * this.lastInputs[i]\n                    + addNew * values[i])\n            }\n            // update history for next time around\n            this.lastTime = timeStamp\n            this.average = result\n            this.lastInputs = values\n\n            return result\n        }\n    }\n\n\n    // An Ellipse is an object holding the characteristics of the (typically) elliptical\n    // view formed when projecting the scan Spin-Circle onto a 2-axis View-plane.\n    class Ellipse {\n        plane: string; // View name (just for debug)\n        uDim: number; // horizontal axis of this View\n        vDim: number; // vertical axis of this View\n        uOff: number; // horizontal offset needed to re-centre this Ellipse along the U-axis\n        vOff: number; // vertical offset needed to re-centre this Ellipse along the V-axis\n\n        // calibration characteristics\n        majorAngle: number; // direction of the Ellipse major axis \n        period: number; // scan-rotation time as viewed in this plane\n        eccentricity: number; // ratio of major-axis to minor-axis magnitudes for this Ellipse\n        isCircular: boolean; // flag saying this \"Ellipse\" View is almost circular, simplifying future handling\n        rotationSense: number; // rotation reversal sign = +/-1, reflecting this Ellipse's view of the clockwise scan\n\n        constructor(plane: string, uDim: number, vDim: number, uOff: number, vOff: number) {\n            this.plane = plane // (as a DEBUG aid)\n            this.uDim = uDim\n            this.vDim = vDim\n            this.uOff = uOff\n            this.vOff = vOff\n            this.isCircular = false // until proved otherwise!\n            this.period = -1\n        }\n\n        // This method analyses a 2-D subset of the scanData for a projected View of the Spin-Circle,\n        // creating an Arrow indicating the major-axis direction of the elliptical View.\n        // It performs several tasks:\n        // 1) By comparing the longest and shortest radii, this method works out the eccentricity of \n        //    the Ellipse, as seen from this View. Also notes whether being viewed \"from below\".\n        // 2) It collects possible candidates for the Ellipse major and minor axes by looking for local \n        //    radius peaks and troughs; candidate values are pushed onto two lists of Arrows:\n        //    this.majors[] and this.minors[]\n        // 3) These lists are then carefully assessed to evolve a consensus for the two axes. \n        //    For \"pointy\" Ellipses we get a single candidate each time we pass either end of the axis.\n        //    For \"rounder\" Ellipses each transit may deliver multiple candidates. If a candidate points \n        //    closer to the head of the ongoing mean, it is added in; if it points closer to the tail, \n        //    then it's inverse is added in (as it must \"belong\" to the other end of the axis).\n        // 4) As we do this, we work out the rotation period by clocking each time we flip ends of the axis.\n        // 5) All this analysis results in a single Arrow for each axis which can be averaged (after turning\n        //    the minor axis through a right-angle)\n\n\n        analyseView() {\n            let majors: Arrow[] = [] // candidate directions for major axis of Ellipse\n            let minors: Arrow[] = [] // candidate directions for minor axis of Ellipse\n            let major: Arrow = new Arrow(0, 0, 0)\n            let minor: Arrow = new Arrow(0, 0, 0)\n            let longest = 0\n            let shortest = 99999\n            let spin = 0\n            let sizeWas: number\n            let angleWas: number\n            let step: number = 99999 // marker for \"first time round\"\n            let stepWas: number\n            // extract coordinates of the first point lying in this.plane\n            let point = [scanData[0][this.uDim], scanData[0][this.vDim]]\n            // set up a 2D Smoother for points on this Ellipse\n            let curve = new Smoother(point, scanTimes[0])\n            // compare first one with remaining samples\n            let trial = new Arrow(point[0], point[1], scanTimes[0])\n            for (let i = 1; i < scanTimes.length; i++) {\n                sizeWas = trial.size\n                angleWas = trial.angle\n                // blend the next point into the moving average\n                point = curve.update([scanData[i][this.uDim], scanData[i][this.vDim]], scanTimes[i])\n                trial = new Arrow(point[0], point[1], scanTimes[i])\n\n                // accumulate gradual rotation of the projected field-vector...\n                let delta = trial.angle - angleWas\n                spin += delta\n                // fix roll-rounds in either direction\n                if (delta > HalfPi) spin -= TwoPi // apparent big positive jump is due to underflow\n                if (delta < -HalfPi) spin += TwoPi // apparent big negative jump is due to overflow\n\n                // now collect candidates for axes  \n                stepWas = step\n                step = trial.size - sizeWas // is radius growing or shrinking (or the same!)?\n                if (stepWas == 99999) stepWas = step // (ensure that the first two steps will always match)\n                if (step == 0) step = stepWas // ignore any (rare!) static sequence by propagating last step\n\n                // look for peaks, where we switch from growing to shrinking\n                if ((stepWas > 0) && (step < 0)) {\n                    longest = Math.max(longest, trial.size)\n                    majors.push(trial.cloneMe()) // copy the major axis we are passing\n                }\n\n                // look for troughs, where we switch from shrinking to growing\n                if ((stepWas < 0) && (step > 0)) {\n                    shortest = Math.min(shortest, trial.size)\n                    minors.push(trial.cloneMe()) // copy the minor axis we are passing\n                }\n\n            }\n            // During a clockwise scan, the projection-angle of the field-vector as viewed from above \n            // will appear to rotate anticlockwise (increasing radians) from the perspective of the Buggy. \n            // If we find it rotates clockwise (decreasing radians) then this projection-plane must be \n            // viewing the field-vector from below.\n            this.rotationSense = spin / Math.abs(spin) // == -1 if viewing from below\n\n            /* PERIODICITY FROM SPIN?\n             Why not simply use the accumulated spin-angle and time-span to calculate the rotation-period?\n             --Because the arbitrary start and end angles may be subject to fore-shortening, and hence\n             quite inaccurate! The only dependable angles occur just as we pass over the axes (see below).\n            */\n\n\n            /* We are trying to find a good approximation to the tilt of the Ellipse's major-axis.  \n            We could simply nominate the longest candidate detected, but instead we will average them.\n\n            If the Ellipse is quite eccentric, it will yield neatly alternating candidates with \n            \"opposite\" angles.passing the major-axis twice per Spin-circle revolution \n\n            With a more-nearly circular Ellipse, noisy readings can yield alternating clusters of local maxima \n            gathered near each end of the axis.\n\n            An almost circular Ellipse has no meaningful axis and generally yields multiple spurious candidates. \n            */\n\n            // purge any local maximum whose vector length is too short --it's nowhere near the major-axis!\n            let long = longest * NearEnough\n            for (let i = 0; i < majors.length; i++) {\n                if (majors[i].size < long) {\n                    majors.splice(i, 1)  // disqualified!\n                    i-- // (all subsequent candidates now shuffle up by one place!)\n                }\n            }\n\n            // similarly purge all errant local minima that are too big\n            let short = shortest / NearEnough\n            for (let i = 0; i < minors.length; i++) {\n                if (minors[i].size > short) {\n                    minors.splice(i, 1)\n                    i--\n                }\n            }\n\n\n            // form consensus averages of the two ends of the two axes\n            major = computeAxis(majors)\n            minor = computeAxis(minors)\n\n            // average the axis angles carefully: minor axis is always orthgonal, but phase may lead or follow!\n            let minorTurned = minor.angle + HalfPi // assume it leads by 90 degrees\n            if (angleSpan(major.angle, minor.angle) > 0) {\n                minorTurned += Math.PI // no: it follows, so add another 180 degrees\n            }\n            // use the average of the two angles\n            this.majorAngle = ((major.angle + minorTurned) / 2) % TwoPi\n            // The ratio of the axis lengths gives the eccentricity of this Ellipse\n            this.eccentricity = major.size / minor.size\n            // average the periodicities detected \n            this.period = (major.time + minor.time) / 2\n            // Readings on a near-circular Ellipse won't ever be fore-shortened, so we can skip correction!\n            this.isCircular = (this.eccentricity < Circular)\n        }\n    }\n\n\n\n    // GLOBALS\n\n    let scanTimes: number[] = [] // sequence of time-stamps for scanned readings \n    let scanData: number[][] = [] // scanned sequence of [X,Y,Z] magnetometer readings\n    let scanTime: number = 0 // duration of scan in ms\n    let views: Ellipse[] = [] // the three possible elliptical views of the Spin-Circle\n    let bestView = -1\n    let uDim = -1 // the \"horizontal\" axis (called U) for the best View\n    let vDim = -1 // the \"vertical\" axis (called V) for the best View\n    let north = 0 // reading registered as \"North\"\n    let strength = 0 // the average magnetic field-strength observed by the magnetometer\n    let period = -1 // overall assessment of average rotation time\n\n    // correction parameters adopted from bestView Ellipse for future readings\n    let rotationSense = 1 // set to -1 if orientation means field-vector projection is \"from below\"\n    let isCircular: boolean // if bestView Ellipse is circular, no correction is needed\n    let uOff: number // horizontal origin offset\n    let vOff: number // vertical origin offset\n    let theta: number  // major-axis tilt angle (in radians anticlockwise from the U-axis)\n    let cosTheta: number; // saved for efficiency\n    let sinTheta: number; //      ditto\n    let scale: number // stretch-factor for correcting foreshortened readings (= eccentricity)\n\n    // EXPORTED USER INTERFACES   \n\n    /** \n     * Assuming the buggy is currently spinning clockwise on the spot, capture a \n     * time-stamped sequence of magnetometer readings from which to set up the compass.\n     *\n     * @param ms scanning-time in millisecs (long enough for more than one full rotation)    \n     */\n\n    //% block=\"scan clockwise for (ms) $ms\" \n    //% inlineInputMode=inline \n    //% ms.shadow=\"timePicker\" \n    //% ms.defl=0 \n    //% weight=90 \n\n    export function scanClockwise(ms: number) {\n        // Sample magnetometer readings periodically over the specified duration (generally a couple\n        // of seconds), and append a new [X,Y,Z] triple to the scanData[] array.\n        // A timestamp for each sample is also recorded in the scanTimes[] array.\n\n        // NOTE: To smooth out jitter, each reading is always a moving average of several consecutive readings.\n        // Because sample-times may be irregular (due to scheduled interrupts), a Smoother is used to provide\n        // a timing-aware exponential moving-average. The sample-grouping and spacing are controlled \n        // respectively by the constants Window and SampleGap, which together determine the Latency.\n\n        scanTimes = []\n        scanData = []\n        let index = 0\n\n        let timeWas: number\n        let timeNow: number\n        let fresh: number[] = []\n        let updated: number[] = []\n\n        basic.pause(200) // wait for motors to stabilise (after initial kick)\n        // get initial reading\n        let timeStamp = input.runningTime()\n        fresh = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n        // use a Smoother to maintain a rolling average\n        let scan = new Smoother(fresh, timeStamp)\n\n        // after an initial settling period, continue cranking out updated moving averages \n        let startTime = timeStamp + Latency\n        let stopTime = timeStamp + ms\n\n        // until we run out of time (or space!)\n        while ((timeStamp < stopTime)\n            && (scanTimes.length < TooManySamples)) {\n            // After processing, sleep until it's time for next sample.\n            // NOTE: here is where various system subprograms will get scheduled.\n            // If they need more time than we've offered, out next sample will get delayed!\n            // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n            timeWas = timeStamp // remember time of latest sample\n            timeNow = input.runningTime()\n            basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n            timeStamp = input.runningTime() // take a fresh set of readings\n\n            fresh = [\n                input.magneticForce(Dimension.X),\n                input.magneticForce(Dimension.Y),\n                input.magneticForce(Dimension.Z)]\n            updated = scan.update(fresh, timeStamp)\n\n            // only start recording once the moving average has stabilised\n            if (timeStamp > startTime) {\n                // store the triple of averaged [X,Y,Z] values (as a deep copy!)\n                scanData.push([updated[0], updated[1], updated[2]])\n                scanTimes.push(timeStamp)  // timestamp it\n                index++\n            }\n        }\n    }\n\n    /**\n     * Analyse the scanned data to prepare for reading compass-bearings.\n     * Then read the magnetometer and register the buggy's current direction as \"North\",\n     * (i.e. the direction that will in future return zero as its heading).\n     * \n     * The actual direction of the buggy when this function is called is arbitrary:\n     * it could be Magnetic North; or True North (compensating for local declination); \n     * or any convenient direction from which to measure subsequent heading angles.\n     * \n     * @return zero if successful, or a negative error code:\n     *\n     *      -1 : NOT ENOUGH SCAN DATA\n\n     *      -2 : FIELD STRENGTH TOO WEAK\n     *\n     *      -3 : NOT ENOUGH SCAN ROTATION\n     *\n     */\n    //% block=\"set North\" \n    //% inlineInputMode=inline \n    //% weight=80 \n    export function setNorth(): number {\n        // reset global defaults\n        bestView = -1\n        strength = -1\n        period = -1\n\n        // First analyse the scan-data to decide how best to use the magnetometer readings.\n        // we'll typically need about a couple of second's worth of scanned readings...\n        let nSamples = scanTimes.length\n        scanTime = scanTimes[nSamples - 1] - scanTimes[0]\n\n        if ((nSamples < EnoughSamples) || (scanTime < EnoughScanTime)) {\n            return -1 // \"NOT ENOUGH SCAN DATA\"\n        }\n        // Each dimension should track a sinusoidal wave of values (generally not centred on zero).\n        // The first pass finds the ranges for each axis \n        let xlo = 9999999\n        let ylo = 9999999\n        let zlo = 9999999\n        let xhi = -9999999\n        let yhi = -9999999\n        let zhi = -9999999\n        for (let i = 0; i < nSamples; i++) {\n            xhi = Math.max(xhi, scanData[i][Dimension.X])\n            yhi = Math.max(yhi, scanData[i][Dimension.Y])\n            zhi = Math.max(zhi, scanData[i][Dimension.Z])\n            xlo = Math.min(xlo, scanData[i][Dimension.X])\n            ylo = Math.min(ylo, scanData[i][Dimension.Y])\n            zlo = Math.min(zlo, scanData[i][Dimension.Z])\n        }\n\n        // get RMS field-strength\n        let xField = (xhi - xlo) / 2\n        let yField = (yhi - ylo) / 2\n        let zField = (zhi - zlo) / 2\n        strength = Math.sqrt((xField * xField) + (yField * yField) + (zField * zField))\n\n        // Bail out early if the scan didn't properly detect the Earth's magnetic field,\n        // (perhaps due to magnetic shielding)\n        if (strength < MarginalField) {\n            return -2 // \"FIELD STRENGTH TOO WEAK\"\n        }\n        // The means of the extremes give an approximation to the central offsets.\n        let xOff = (xhi + xlo) / 2\n        let yOff = (yhi + ylo) / 2\n        let zOff = (zhi + zlo) / 2\n\n        // re-centre all of the scanData samples, so eliminating \"hard-iron\" magnetic effects\n        for (let i = 0; i < nSamples; i++) {\n            scanData[i][Dimension.X] -= xOff\n            scanData[i][Dimension.Y] -= yOff\n            scanData[i][Dimension.Z] -= zOff\n        }\n\n        // create three Ellipse instances for analysing each possible view in turn\n        views.push(new Ellipse(\"XY\", Dimension.X, Dimension.Y, xOff, yOff))\n        views.push(new Ellipse(\"YZ\", Dimension.Y, Dimension.Z, yOff, zOff))\n        views.push(new Ellipse(\"ZX\", Dimension.Z, Dimension.X, zOff, xOff))\n\n        // For each View, perform the analysis of eccentricity and Ellipse tilt-angle\n        views[View.XY].analyseView()\n        views[View.YZ].analyseView()\n        views[View.ZX].analyseView()\n\n        // check that at least one View saw at least one complete rotation (with a measurable period)...\n        if ((views[View.XY].period == -1)\n            && (views[View.YZ].period == -1)\n            && (views[View.ZX].period == -1)) {\n            return -3 // \"NOT ENOUGH SCAN ROTATION\"\n        }\n\n        // Choose the \"roundest\" Ellipse  --the one with lowest eccentricity.\n        bestView = View.XY\n        if (views[View.YZ].eccentricity < views[bestView].eccentricity) bestView = View.YZ\n        if (views[View.ZX].eccentricity < views[bestView].eccentricity) bestView = View.ZX\n\n        // periodicity is unreliable in a near-circular View: average just the other two Views' measurements\n        period = (views[0].period + views[1].period + views[2].period - views[bestView].period) / 2\n\n        // For efficiency, extract various characteristics from our adopted \"bestView\" Ellipse\n        uDim = views[bestView].uDim\n        vDim = views[bestView].vDim\n        uOff = views[bestView].uOff\n        vOff = views[bestView].vOff\n        scale = views[bestView].eccentricity // scaling needed to balance axes\n        theta = views[bestView].majorAngle // the rotation (in radians) of the major-axis from the U-axis\n        cosTheta = Math.cos(theta)\n        sinTheta = Math.sin(theta)\n        isCircular = views[bestView].isCircular\n        rotationSense = views[bestView].rotationSense\n\n        // Having successfully set up the projection parameters for the bestView, get a\n        // stable fix on the current heading, which we will then designate as \"North\".\n        // (This is the global fixed bias to be subtracted from all future readings)\n        north = takeSingleReading()\n\n        // we've now finished with the scanning data and Ellipse objects, so release their memory\n        scanTimes = []\n        scanData = []\n        views = []\n\n        // SUCCESS!\n        return 0\n    }\n\n\n    /**\n     * Read the magnetometer\n     * \n     * @return the current heading of the buggy\n     * \n     * (in degrees clockwise, relative to \"North\")\n     */\n    //% block=\"degrees\" \n    //% inlineInputMode=inline \n    //% weight=70\n    export function degrees(): number {\n        // Depending on mounting orientation, the bestView might possibly be seeing the Spin-Circle from\n        // \"underneath\", with the field-vector appearing to move clockwise  --effectively experiencing an\n        // anti-clockwise scan. In this case the rotationSense will be negative.\n        return asDegrees((takeSingleReading() - north) * rotationSense)\n        // NOTE: that there is a double reversal going on here:\n        // Viewed from above, the Field-vector reading in radians INCREASES (anticlockwise) w.r.t \"North\"\n        // as the buggy's compass-heading INCREASES (clockwise).\n        // So after a right-turn while facing North, the reading is HalfPi bigger than the North reading.\n        // After subtracting North (cyclically), that converts asDegrees() to +90 \n        // From below (when rotationSense = -1), the same right-turn would DECREASE the reading by HalfPi\n        // necessitating a third reversal (after first subtracting North) !\n    }\n\n    /**\n     * The average rotation time of the most recent scan \n     * @return rotation time, or error-value:\n     * \n     *      -4 : SUCCESSFUL SCAN IS NEEDED FIRST\n     */\n    //% block=\"spin time (ms)\" \n    //% inlineInputMode=inline \n    //% weight=60 \n    export function spinTime(): number {\n        if (period == -1) {\n            return -4 // ERROR: SUCCESSFUL SCAN IS NEEDED FIRST\n        } else {\n            return period\n        }\n    }\n\n    /**\n     * The average rotation rate of the most recent scan \n     * \n     * @return revs-per-minute, or error value:\n     * \n     *      -4 : SUCCESSFUL SCAN IS NEEDED FIRST\n     */\n    //% block=\"spin rate (RPM)\" \n    //% inlineInputMode=inline \n    //% weight=50 \n    export function spinRate(): number {\n        if (period == -1) {\n            return -4 // ERROR: SUCCESSFUL SCAN IS NEEDED FIRST\n        } else {\n            return 60000 / period\n        }\n    }\n\n    /**\n     * While scanning, wheels are rotated in opposite directions, giving a spin-rate for the \n     * selected power setting. Based on the axle-length and latest spin-rate, this function \n     * estimates the forward speed to be expected when using that power setting.\n     * (NOTE that tyre-friction or skidding when turning may make this a fairly inaccurate estimate!)\n     * \n     * @param axleLength : distance betweeen mid-lines of tyres (in mm)\n     * \n     * @return speed in mm-per-second, or error value:\n     * \n     *      -4 : SUCCESSFUL SCAN IS NEEDED FIRST\n     */\n    //% block=\"equivalent speed (mm/s), axle length (mm) = $axleLength\" \n    //% inlineInputMode=inline \n    //% weight=50 \n    export function equivalentSpeed(axleLength: number): number {\n        if (period < 0) {\n            return -4 // ERROR: SUCCESSFUL SCAN IS NEEDED FIRST\n        } else {\n            // compute tangential speed of wheel-centre in mm/s:\n            // it takes [period] ms to cover [2pi * axleLength/2] mm\n            return (Math.PI * axleLength * 1000 / period)\n        }\n    }\n\n\n    // UTILITY FUNCTIONS\n\n    /** Take the sum of several new readings to get a stable fix on the current heading.\n     *  @return the projected angle of the magnetic field-vector (in radians anticlockwise\n     * from the horizontal U-axis)\n     */\n\n    function takeSingleReading(): number {\n        let uRaw = 0\n        let vRaw = 0\n        let u = 0\n        let v = 0\n        let uNew = 0\n        let vNew = 0\n        let uFix = 0\n        let vFix = 0\n        let reading = 0\n        // get a new sample as the average of {Window} consecutive 2D readings, {SampleGap} apart\n        for (let i = 0; i < Window; i++) {\n            basic.pause(SampleGap)\n            uRaw += input.magneticForce(uDim)\n            vRaw += input.magneticForce(vDim)\n        }\n        uRaw /= Window\n        vRaw /= Window\n\n        // re-centre this latest point w.r.t our Ellipse origin\n        u = uRaw - uOff\n        v = vRaw - vOff\n\n        if (isCircular) {\n            reading = Math.atan2(v, u)\n        } else {\n            // Unless this Ellipse.isCircular, any {u,v} reading will be foreshortened in this View, and\n            // must be stretched along the Ellipse minor-axis to place it correctly onto the Spin-Circle.\n\n            // First rotate CLOCKWISE by theta (so aligning the Ellipse minor-axis angle with the V-axis)\n            uNew = u * cosTheta + v * sinTheta\n            vNew = v * cosTheta - u * sinTheta\n            // Now scale up along V, re-balancing the axes to make the Ellipse circular\n            uFix = uNew\n            vFix = vNew * scale\n            // get the adjusted angle for this corrected {u,v}\n            reading = Math.atan2(vFix, uFix)\n            // finally, undo the rotation by theta\n            reading += theta\n        }\n        return reading\n    }\n\n    /* Use vector addition to average a sequence of candidate axis Arrows (concievably empty!)\n    // The ones pointing away from the first one are assumed to belong to the other end\n    // of the axis, so will get reversed.\n    // The returned Arrow shows the average axis length and angle.\n    // Assuming candidates represent more than one revolution, the periodocity is also calculated.\n    */\n    function computeAxis(sheaf: Arrow[]): Arrow {\n        let result = new Arrow(0, 0, 0)\n        let turns = 0\n        let startTime = 0\n        let endTime = 0\n        let period = -1\n        let flipped = false\n        let uSum = 0\n        let vSum = 0\n        let rSum = 0\n        let count = sheaf.length\n        if (count > 0) {\n            // initialise axis as first (or only?) candidate\n            uSum = sheaf[0].u\n            vSum = sheaf[0].v\n            rSum = sheaf[0].size\n            let axis = sheaf[0].angle\n            startTime = sheaf[0].time\n            flipped = false\n            for (let i = 1; i < count; i++) {\n                // does next candidate point nearer the head or the tail of the axis?\n                if (Math.abs(angleSpan(axis, sheaf[i].angle)) < HalfPi) {\n                    // chain this candidate onto the emerging axis\n                    uSum += sheaf[i].u\n                    vSum += sheaf[i].v\n                    // the first unflipped candidate after one or more flipped ones clocks a new revolution\n                    if (flipped) {\n                        flipped = false\n                        turns++\n                        endTime = sheaf[i].time\n                    }\n                } else { // flip this arrow before chaining it, as it's pointing the \"wrong\" way\n                    flipped = true\n                    uSum -= sheaf[i].u\n                    vSum -= sheaf[i].v\n                }\n                // get the new blended angle\n                axis = Math.atan2(vSum, uSum)\n                rSum += sheaf[i].size\n            }\n\n            // build the result Arrow\n            result.size = rSum / count  // the average radius\n            result.angle = axis\n            result.u = result.size * Math.cos(axis)\n            result.v = result.size * Math.sin(axis)\n\n            // compute the average rotation time (so long as we've made at least one complete revolution)\n            if (endTime > 0) {\n                result.time = (endTime - startTime) / turns\n            }\n        }\n        // hijack the time property to return the estimated period\n        return result\n    }\n\n\n    /** gives the signed difference between angles a & b (allowing for roll-round)\n     * @param a first angle in radians\n     * @param b second angle in radians\n     * @returns the acute (i.e. smaller) difference in angle\n     */\n    function angleSpan(a: number, b: number) {\n        return ((ThreePi + b - a) % TwoPi) - Math.PI\n    }\n\n    // Convert an angle measured in radians to degrees.\n    function asDegrees(angle: number): number {\n        return ((angle * RadianDegrees) + 360) % 360\n    }\n}\n","pxt.json":"{\n    \"name\": \"heading test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"pxt-heading.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1721543301173,"editorVersion":"7.0.13","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let spinRPM = 0\" numlines=\"1\" declaredvars=\"spinRPM\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let result = 0\" numlines=\"1\" declaredvars=\"result\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"enum Task {\" line1=\"    Scan,\" line2=\"    SetNorth,\" line3=\"    Measure\" line4=\"}\" numlines=\"5\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let nextTask: Task = Task.Scan\" numlines=\"1\" declaredvars=\"nextTask\"></mutation><comment pinned=\"false\" h=\"50\" w=\"50\">new mode, so always start with a scan</comment><next><block type=\"basic_show_arrow\"><value name=\"i\"><shadow type=\"device_arrow\"><field name=\"arrow\">ArrowNames.West</field></shadow></value></block></next></block></next></block></next></block></next></block></statement></block><block type=\"device_button_event\" x=\"366\" y=\"0\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"performSetup\" functionid=\"[vA;:54=Q=ye][K9n$dl\"></mutation></block></statement></block><block type=\"device_button_event\" x=\"628\" y=\"0\"><field name=\"NAME\">Button.B</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"measure\" functionid=\"(?z$N_d[_95s,b)]Uce3\"></mutation></block></statement></block><block type=\"function_definition\" x=\"891\" y=\"0\"><mutation name=\"performSetup\" functionid=\"[vA;:54=Q=ye][K9n$dl\"></mutation><field name=\"function_name\">performSetup</field><statement name=\"STACK\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"switch (nextTask) {\" line1=\"        case Task.Scan:\" line2=\"            let scanTime = 6000 // ...to MANUALLY rotate turntable jig twice (SMOOOOTHLY!)\" line3=\"            basic.showString(&quot;S&quot;)\" line4=\"            basic.pause(1000)\" line5=\"            basic.showString(&quot;_&quot;)\" line6=\"            heading.scanClockwise(scanTime)\" line7=\"            basic.showIcon(IconNames.Yes)\" line8=\"            basic.pause(1000)\" line9=\"            basic.clearScreen()\" line10=\"            basic.showArrow(ArrowNames.West)\" line11=\"            nextTask = Task.SetNorth\" line12=\"            break\" line13=\"\" line14=\"        case Task.SetNorth:\" line15=\"            basic.showString(&quot;N&quot;)\" line16=\"            basic.pause(1000)\" line17=\"            basic.clearScreen()\" line18=\"            result = heading.setNorth()\" line19=\"\" line20=\"            if (result &lt; 0) {\" line21=\"                basic.showIcon(IconNames.Skull) // problem with scan data analysis\" line22=\"                basic.pause(1000)\" line23=\"                basic.showNumber(result)\" line24=\"                basic.pause(1000)\" line25=\"                basic.clearScreen()\" line26=\"                basic.showArrow(ArrowNames.West)\" line27=\"                nextTask = Task.Scan // restart with a fresh scan\" line28=\"            } else {\" line29=\"                spinRPM = heading.spinRate() // ...just out of interest\" line30=\"                basic.showNumber(Math.floor(spinRPM))\" line31=\"                basic.pause(1000)\" line32=\"                basic.showIcon(IconNames.Yes)\" line33=\"                basic.pause(500)\" line34=\"                basic.showLeds(`\" line35=\"                    # # . # #\" line36=\"                    # . . . #\" line37=\"                    . . # . .\" line38=\"                    # . . . #\" line39=\"                    # # . # #\" line40=\"                    `)\" line41=\"                basic.pause(500)\" line42=\"                basic.showArrow(ArrowNames.East)\" line43=\"                nextTask = Task.Measure\" line44=\"            }\" line45=\"            break\" line46=\"\" line47=\"        case Task.Measure: // Button A allows new North setting\" line48=\"            basic.showIcon(IconNames.No)\" line49=\"            basic.pause(1000)\" line50=\"            basic.clearScreen()\" line51=\"            basic.showArrow(ArrowNames.West)\" line52=\"            nextTask = Task.SetNorth // reset new North\" line53=\"            break\" line54=\"    }\" numlines=\"55\"></mutation></block></statement></block><block type=\"function_definition\" x=\"1760\" y=\"0\"><mutation name=\"measure\" functionid=\"(?z$N_d[_95s,b)]Uce3\"></mutation><field name=\"function_name\">measure</field><statement name=\"STACK\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"switch (nextTask) {\" line1=\"        // ? sequence error?\" line2=\"        case Task.SetNorth:\" line3=\"        case Task.Scan: // use button A to do a scan first\" line4=\"            for (let i = 0; i &lt; 5; i++) {\" line5=\"                basic.clearScreen()\" line6=\"                basic.pause(100)\" line7=\"                basic.showArrow(ArrowNames.West)\" line8=\"            }\" line9=\"            break\" line10=\"\" line11=\"        case Task.Measure: // OK, take a new heading measurement\" line12=\"            basic.pause(200)\" line13=\"            basic.clearScreen()\" line14=\"            basic.pause(50)\" line15=\"            let compass = heading.degrees()\" line16=\"            basic.showNumber(Math.floor(compass))\" line17=\"            basic.pause(500)\" line18=\"            // now MANUALLY move to next test-angle...\" line19=\"            basic.showLeds(`\" line20=\"                    # # . # #\" line21=\"                    # . . . #\" line22=\"                    . . . . .\" line23=\"                    # . . . #\" line24=\"                    # # . # #\" line25=\"                    `)\" line26=\"            basic.pause(200)\" line27=\"            break\" line28=\"    }\" numlines=\"29\"></mutation></block></statement></block></xml>","main.ts":"","README.md":"","pxt.json":"{\n    \"name\": \"heading test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-heading\": \"workspace:23ae8b4e-fd30-4cfc-7934-39b860ebd793\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"blocksprj\"\n}\n"}},{"timestamp":1721573050729,"editorVersion":"7.0.13","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let result = 0\" numlines=\"1\" declaredvars=\"result\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let spinRPM = 0\" numlines=\"1\" declaredvars=\"spinRPM\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"enum Task {\" line1=\"    Scan,\" line2=\"    SetNorth,\" line3=\"    Measure\" line4=\"}\" numlines=\"5\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let nextTask: Task = Task.Scan\" numlines=\"1\" declaredvars=\"nextTask\"></mutation><next><block type=\"basic_show_arrow\"><value name=\"i\"><shadow type=\"device_arrow\"><field name=\"arrow\">ArrowNames.West</field></shadow></value></block></next></block></next></block></next></block></next></block></statement></block><block type=\"device_button_event\" x=\"361\" y=\"20\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"performSetup\" functionid=\"kuGBiGbnq;{hUPB-]Or3\"></mutation></block></statement></block><block type=\"device_button_event\" x=\"623\" y=\"20\"><field name=\"NAME\">Button.B</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"measure\" functionid=\"R@84t::DXQ2#H72`|rg-\"></mutation></block></statement></block><block type=\"function_definition\" x=\"886\" y=\"20\"><mutation name=\"performSetup\" functionid=\"kuGBiGbnq;{hUPB-]Or3\"></mutation><field name=\"function_name\">performSetup</field><statement name=\"STACK\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"switch (nextTask) {\" line1=\"        case Task.Scan:\" line2=\"            let scanTime = 6000 // ...to MANUALLY rotate turntable jig twice (SMOOOOTHLY!)\" line3=\"            basic.showString(&quot;S&quot;)\" line4=\"            basic.pause(1000)\" line5=\"            basic.showString(&quot;_&quot;)\" line6=\"            heading.scanClockwise(scanTime)\" line7=\"            basic.showIcon(IconNames.Yes)\" line8=\"            basic.pause(1000)\" line9=\"            basic.clearScreen()\" line10=\"            basic.showArrow(ArrowNames.West)\" line11=\"            nextTask = Task.SetNorth\" line12=\"            break\" line13=\"\" line14=\"        case Task.SetNorth:\" line15=\"            basic.showString(&quot;N&quot;)\" line16=\"            basic.pause(1000)\" line17=\"            basic.clearScreen()\" line18=\"            result = heading.setNorth()\" line19=\"\" line20=\"            if (result &lt; 0) {\" line21=\"                basic.showIcon(IconNames.Skull) // problem with scan data analysis\" line22=\"                basic.pause(1000)\" line23=\"                basic.showNumber(result)\" line24=\"                basic.pause(1000)\" line25=\"                basic.clearScreen()\" line26=\"                basic.showArrow(ArrowNames.West)\" line27=\"                nextTask = Task.Scan // restart with a fresh scan\" line28=\"            } else {\" line29=\"                spinRPM = heading.spinRate() // ...just out of interest\" line30=\"                basic.showNumber(Math.floor(spinRPM))\" line31=\"                basic.pause(1000)\" line32=\"                basic.showIcon(IconNames.Yes)\" line33=\"                basic.pause(500)\" line34=\"                basic.showLeds(`\" line35=\"                    # # . # #\" line36=\"                    # . . . #\" line37=\"                    . . # . .\" line38=\"                    # . . . #\" line39=\"                    # # . # #\" line40=\"                    `)\" line41=\"                basic.pause(500)\" line42=\"                basic.showArrow(ArrowNames.East)\" line43=\"                nextTask = Task.Measure\" line44=\"            }\" line45=\"            break\" line46=\"\" line47=\"        case Task.Measure: // Button A allows new North setting\" line48=\"            basic.showIcon(IconNames.No)\" line49=\"            basic.pause(1000)\" line50=\"            basic.clearScreen()\" line51=\"            basic.showArrow(ArrowNames.West)\" line52=\"            nextTask = Task.SetNorth // reset new North\" line53=\"            break\" line54=\"    }\" numlines=\"55\"></mutation></block></statement></block><block type=\"function_definition\" x=\"1755\" y=\"20\"><mutation name=\"measure\" functionid=\"R@84t::DXQ2#H72`|rg-\"></mutation><field name=\"function_name\">measure</field><statement name=\"STACK\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"switch (nextTask) {\" line1=\"        // ? sequence error?\" line2=\"        case Task.SetNorth:\" line3=\"        case Task.Scan: // use button A to do a scan first\" line4=\"            for (let i = 0; i &lt; 5; i++) {\" line5=\"                basic.clearScreen()\" line6=\"                basic.pause(100)\" line7=\"                basic.showArrow(ArrowNames.West)\" line8=\"            }\" line9=\"            break\" line10=\"\" line11=\"        case Task.Measure: // OK, take a new heading measurement\" line12=\"            basic.pause(200)\" line13=\"            basic.clearScreen()\" line14=\"            basic.pause(50)\" line15=\"            let compass = heading.degrees()\" line16=\"            basic.showNumber(Math.floor(compass))\" line17=\"            basic.pause(500)\" line18=\"            // now MANUALLY move to next test-angle...\" line19=\"            basic.showLeds(`\" line20=\"                    # # . # #\" line21=\"                    # . . . #\" line22=\"                    . . . . .\" line23=\"                    # . . . #\" line24=\"                    # # . # #\" line25=\"                    `)\" line26=\"            basic.pause(200)\" line27=\"            break\" line28=\"    }\" numlines=\"29\"></mutation></block></statement></block></xml>","main.ts":"","README.md":"","pxt.json":"{\n    \"name\": \"heading test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-heading\": \"workspace:23ae8b4e-fd30-4cfc-7934-39b860ebd793\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"blocksprj\"\n}\n"}},{"timestamp":1721627857416,"editorVersion":"7.0.13","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let result = 0\" numlines=\"1\" declaredvars=\"result\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let spinRPM = 0\" numlines=\"1\" declaredvars=\"spinRPM\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"enum Task {\" line1=\"    Scan,\" line2=\"    SetNorth,\" line3=\"    Measure\" line4=\"}\" numlines=\"5\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let nextTask: Task = Task.Scan\" numlines=\"1\" declaredvars=\"nextTask\"></mutation><next><block type=\"basic_show_arrow\"><value name=\"i\"><shadow type=\"device_arrow\"><field name=\"arrow\">ArrowNames.West</field></shadow></value></block></next></block></next></block></next></block></next></block></statement></block><block type=\"device_button_event\" x=\"341\" y=\"0\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"performSetup\" functionid=\"kuGBiGbnq;{hUPB-]Or3\"></mutation></block></statement></block><block type=\"device_button_event\" x=\"603\" y=\"0\"><field name=\"NAME\">Button.B</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"measure\" functionid=\"R@84t::DXQ2#H72`|rg-\"></mutation></block></statement></block><block type=\"function_definition\" x=\"866\" y=\"0\"><mutation name=\"performSetup\" functionid=\"kuGBiGbnq;{hUPB-]Or3\"></mutation><field name=\"function_name\">performSetup</field><statement name=\"STACK\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"switch (nextTask) {\" line1=\"        case Task.Scan:\" line2=\"            let scanTime = 6000 // ...to MANUALLY rotate turntable jig twice (SMOOOOTHLY!)\" line3=\"            basic.showString(&quot;S&quot;)\" line4=\"            basic.pause(1000)\" line5=\"            basic.showString(&quot;_&quot;)\" line6=\"            heading.scanClockwise(scanTime)\" line7=\"            basic.showIcon(IconNames.Yes)\" line8=\"            basic.pause(1000)\" line9=\"            basic.clearScreen()\" line10=\"            basic.showArrow(ArrowNames.West)\" line11=\"            nextTask = Task.SetNorth\" line12=\"            break\" line13=\"\" line14=\"        case Task.SetNorth:\" line15=\"            basic.showString(&quot;N&quot;)\" line16=\"            basic.pause(1000)\" line17=\"            basic.clearScreen()\" line18=\"            result = heading.setNorth()\" line19=\"\" line20=\"            if (result &lt; 0) {\" line21=\"                basic.showIcon(IconNames.Skull) // problem with scan data analysis\" line22=\"                basic.pause(1000)\" line23=\"                basic.showNumber(result)\" line24=\"                basic.pause(1000)\" line25=\"                basic.clearScreen()\" line26=\"                basic.showArrow(ArrowNames.West)\" line27=\"                nextTask = Task.Scan // restart with a fresh scan\" line28=\"            } else {\" line29=\"                spinRPM = heading.spinRate() // ...just out of interest\" line30=\"                basic.showNumber(Math.floor(spinRPM))\" line31=\"                basic.pause(1000)\" line32=\"                basic.showIcon(IconNames.Yes)\" line33=\"                basic.pause(500)\" line34=\"                basic.showLeds(`\" line35=\"                    # # . # #\" line36=\"                    # . . . #\" line37=\"                    . . # . .\" line38=\"                    # . . . #\" line39=\"                    # # . # #\" line40=\"                    `)\" line41=\"                basic.pause(500)\" line42=\"                basic.showArrow(ArrowNames.East)\" line43=\"                nextTask = Task.Measure\" line44=\"            }\" line45=\"            break\" line46=\"\" line47=\"        case Task.Measure: // Button A allows new North setting\" line48=\"            basic.showIcon(IconNames.No)\" line49=\"            basic.pause(1000)\" line50=\"            basic.clearScreen()\" line51=\"            basic.showArrow(ArrowNames.West)\" line52=\"            nextTask = Task.SetNorth // reset new North\" line53=\"            break\" line54=\"    }\" numlines=\"55\"></mutation></block></statement></block><block type=\"function_definition\" x=\"1735\" y=\"0\"><mutation name=\"measure\" functionid=\"R@84t::DXQ2#H72`|rg-\"></mutation><field name=\"function_name\">measure</field><statement name=\"STACK\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"switch (nextTask) {\" line1=\"        // ? sequence error?\" line2=\"        case Task.SetNorth:\" line3=\"        case Task.Scan: // use button A to do a scan first\" line4=\"            for (let i = 0; i &lt; 5; i++) {\" line5=\"                basic.clearScreen()\" line6=\"                basic.pause(100)\" line7=\"                basic.showArrow(ArrowNames.West)\" line8=\"            }\" line9=\"            break\" line10=\"\" line11=\"        case Task.Measure: // OK, take a new heading measurement\" line12=\"            basic.pause(200)\" line13=\"            basic.clearScreen()\" line14=\"            basic.pause(50)\" line15=\"            let compass = heading.degrees()\" line16=\"            basic.showNumber(Math.floor(compass))\" line17=\"            basic.pause(500)\" line18=\"            // now MANUALLY move to next test-angle...\" line19=\"            basic.showLeds(`\" line20=\"                    # # . # #\" line21=\"                    # . . . #\" line22=\"                    . . . . .\" line23=\"                    # . . . #\" line24=\"                    # # . # #\" line25=\"                    `)\" line26=\"            basic.pause(200)\" line27=\"            break\" line28=\"    }\" numlines=\"29\"></mutation></block></statement></block></xml>","main.ts":"function performSetup () {\n    switch (nextTask) {\n        case Task.Scan:\n            let scanTime = 6000 // ...to MANUALLY rotate turntable jig twice (SMOOOOTHLY!)\n            basic.showString(\"S\")\n            basic.pause(1000)\n            basic.showString(\"_\")\n            heading.scanClockwise(scanTime)\n            basic.showIcon(IconNames.Yes)\n            basic.pause(1000)\n            basic.clearScreen()\n            basic.showArrow(ArrowNames.West)\n            nextTask = Task.SetNorth\n            break\n\n        case Task.SetNorth:\n            basic.showString(\"N\")\n            basic.pause(1000)\n            basic.clearScreen()\n            result = heading.setNorth()\n\n            if (result < 0) {\n                basic.showIcon(IconNames.Skull) // problem with scan data analysis\n                basic.pause(1000)\n                basic.showNumber(result)\n                basic.pause(1000)\n                basic.clearScreen()\n                basic.showArrow(ArrowNames.West)\n                nextTask = Task.Scan // restart with a fresh scan\n            } else {\n                spinRPM = heading.spinRate() // ...just out of interest\n                basic.showNumber(Math.floor(spinRPM))\n                basic.pause(1000)\n                basic.showIcon(IconNames.Yes)\n                basic.pause(500)\n                basic.showLeds(`\n                    # # . # #\n                    # . . . #\n                    . . # . .\n                    # . . . #\n                    # # . # #\n                    `)\n                basic.pause(500)\n                basic.showArrow(ArrowNames.East)\n                nextTask = Task.Measure\n            }\n            break\n\n        case Task.Measure: // Button A allows new North setting\n            basic.showIcon(IconNames.No)\n            basic.pause(1000)\n            basic.clearScreen()\n            basic.showArrow(ArrowNames.West)\n            nextTask = Task.SetNorth // reset new North\n            break\n    }\n}\ninput.onButtonPressed(Button.A, function () {\n    performSetup()\n})\ninput.onButtonPressed(Button.B, function () {\n    measure()\n})\nfunction measure () {\n    switch (nextTask) {\n        // ? sequence error?\n        case Task.SetNorth:\n        case Task.Scan: // use button A to do a scan first\n            for (let i = 0; i < 5; i++) {\n                basic.clearScreen()\n                basic.pause(100)\n                basic.showArrow(ArrowNames.West)\n            }\n            break\n\n        case Task.Measure: // OK, take a new heading measurement\n            basic.pause(200)\n            basic.clearScreen()\n            basic.pause(50)\n            let compass = heading.degrees()\n            basic.showNumber(Math.floor(compass))\n            basic.pause(500)\n            // now MANUALLY move to next test-angle...\n            basic.showLeds(`\n                    # # . # #\n                    # . . . #\n                    . . . . .\n                    # . . . #\n                    # # . # #\n                    `)\n            basic.pause(200)\n            break\n    }\n}\nlet result = 0\nlet spinRPM = 0\nenum Task {\n    Scan,\n    SetNorth,\n    Measure\n}\nlet nextTask: Task = Task.Scan\nbasic.showArrow(ArrowNames.West)\n","README.md":"","pxt.json":"{\n    \"name\": \"heading test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-heading\": \"github:grandpabond/pxt-heading#v1.1.2\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[]}